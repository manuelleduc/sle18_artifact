/*
 * generated by Xtext
 */
package org.xtext.lua.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class LuaGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ChunkElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Chunk");
		private final RuleCall cBlockParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Chunk hidden(WS, COMMENT):
		//	Block;
		@Override public ParserRule getRule() { return rule; }

		//Block
		public RuleCall getBlockParserRuleCall() { return cBlockParserRuleCall; }
	}

	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cStatementsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cStatementsStatementParserRuleCall_1_0_0 = (RuleCall)cStatementsAssignment_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cReturnValueAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cReturnValueLastStatementParserRuleCall_2_0_0 = (RuleCall)cReturnValueAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		
		//Block hidden(WS, COMMENT):
		//	{Block} (statements+=Statement ";"?)* (returnValue=LastStatement ";"?)?;
		@Override public ParserRule getRule() { return rule; }

		//{Block} (statements+=Statement ";"?)* (returnValue=LastStatement ";"?)?
		public Group getGroup() { return cGroup; }

		//{Block}
		public Action getBlockAction_0() { return cBlockAction_0; }

		//(statements+=Statement ";"?)*
		public Group getGroup_1() { return cGroup_1; }

		//statements+=Statement
		public Assignment getStatementsAssignment_1_0() { return cStatementsAssignment_1_0; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_1_0_0() { return cStatementsStatementParserRuleCall_1_0_0; }

		//";"?
		public Keyword getSemicolonKeyword_1_1() { return cSemicolonKeyword_1_1; }

		//(returnValue=LastStatement ";"?)?
		public Group getGroup_2() { return cGroup_2; }

		//returnValue=LastStatement
		public Assignment getReturnValueAssignment_2_0() { return cReturnValueAssignment_2_0; }

		//LastStatement
		public RuleCall getReturnValueLastStatementParserRuleCall_2_0_0() { return cReturnValueLastStatementParserRuleCall_2_0_0; }

		//";"?
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }
	}

	public class LastStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LastStatement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLastStatement_ReturnParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLastStatement_BreakParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// ****************************************************
		//// LAST STATEMENT
		//// ****************************************************
		//LastStatement:
		//	LastStatement_Return | LastStatement_Break;
		@Override public ParserRule getRule() { return rule; }

		//LastStatement_Return | LastStatement_Break
		public Alternatives getAlternatives() { return cAlternatives; }

		//LastStatement_Return
		public RuleCall getLastStatement_ReturnParserRuleCall_0() { return cLastStatement_ReturnParserRuleCall_0; }

		//LastStatement_Break
		public RuleCall getLastStatement_BreakParserRuleCall_1() { return cLastStatement_BreakParserRuleCall_1; }
	}

	public class LastStatement_ReturnElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LastStatement_Return");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cReturnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cLastStatement_ReturnWithValueAction_1 = (Action)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cReturnValuesAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cReturnValuesExpressionParserRuleCall_2_0_0 = (RuleCall)cReturnValuesAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cReturnValuesAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cReturnValuesExpressionParserRuleCall_2_1_1_0 = (RuleCall)cReturnValuesAssignment_2_1_1.eContents().get(0);
		
		//// The return statement is used to return values from a function or a chunk
		//LastStatement_Return:
		//	"return" {LastStatement_ReturnWithValue} (returnValues+=Expression ("," returnValues+=Expression)*)?;
		@Override public ParserRule getRule() { return rule; }

		//"return" {LastStatement_ReturnWithValue} (returnValues+=Expression ("," returnValues+=Expression)*)?
		public Group getGroup() { return cGroup; }

		//"return"
		public Keyword getReturnKeyword_0() { return cReturnKeyword_0; }

		//{LastStatement_ReturnWithValue}
		public Action getLastStatement_ReturnWithValueAction_1() { return cLastStatement_ReturnWithValueAction_1; }

		//(returnValues+=Expression ("," returnValues+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }

		//returnValues+=Expression
		public Assignment getReturnValuesAssignment_2_0() { return cReturnValuesAssignment_2_0; }

		//Expression
		public RuleCall getReturnValuesExpressionParserRuleCall_2_0_0() { return cReturnValuesExpressionParserRuleCall_2_0_0; }

		//("," returnValues+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//returnValues+=Expression
		public Assignment getReturnValuesAssignment_2_1_1() { return cReturnValuesAssignment_2_1_1; }

		//Expression
		public RuleCall getReturnValuesExpressionParserRuleCall_2_1_1_0() { return cReturnValuesExpressionParserRuleCall_2_1_1_0; }
	}

	public class LastStatement_BreakElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LastStatement_Break");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBreakKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cLastStatement_BreakAction_1 = (Action)cGroup.eContents().get(1);
		
		//// The break statement is used to terminate the execution of a while, repeat, or for loop, skipping to the next statement after the loop
		//LastStatement_Break:
		//	"break" {LastStatement_Break};
		@Override public ParserRule getRule() { return rule; }

		//"break" {LastStatement_Break}
		public Group getGroup() { return cGroup; }

		//"break"
		public Keyword getBreakKeyword_0() { return cBreakKeyword_0; }

		//{LastStatement_Break}
		public Action getLastStatement_BreakAction_1() { return cLastStatement_BreakAction_1; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStatement_BlockParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStatement_WhileParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStatement_RepeatParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cStatement_If_Then_ElseParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cStatement_For_NumericParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cStatement_For_GenericParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cStatement_GlobalFunction_DeclarationParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cStatement_LocalFunction_DeclarationParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cStatement_Local_Variable_DeclarationParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cStatement_FunctioncallOrAssignmentParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		
		//// ****************************************************
		//// STATEMENT
		//// ****************************************************
		//Statement hidden(WS, COMMENT):
		//	Statement_Block | Statement_While | Statement_Repeat | Statement_If_Then_Else | Statement_For_Numeric |
		//	Statement_For_Generic | Statement_GlobalFunction_Declaration | Statement_LocalFunction_Declaration |
		//	Statement_Local_Variable_Declaration | Statement_FunctioncallOrAssignment;
		@Override public ParserRule getRule() { return rule; }

		//Statement_Block | Statement_While | Statement_Repeat | Statement_If_Then_Else | Statement_For_Numeric |
		//Statement_For_Generic | Statement_GlobalFunction_Declaration | Statement_LocalFunction_Declaration |
		//Statement_Local_Variable_Declaration | Statement_FunctioncallOrAssignment
		public Alternatives getAlternatives() { return cAlternatives; }

		//Statement_Block
		public RuleCall getStatement_BlockParserRuleCall_0() { return cStatement_BlockParserRuleCall_0; }

		//Statement_While
		public RuleCall getStatement_WhileParserRuleCall_1() { return cStatement_WhileParserRuleCall_1; }

		//Statement_Repeat
		public RuleCall getStatement_RepeatParserRuleCall_2() { return cStatement_RepeatParserRuleCall_2; }

		//Statement_If_Then_Else
		public RuleCall getStatement_If_Then_ElseParserRuleCall_3() { return cStatement_If_Then_ElseParserRuleCall_3; }

		//Statement_For_Numeric
		public RuleCall getStatement_For_NumericParserRuleCall_4() { return cStatement_For_NumericParserRuleCall_4; }

		//Statement_For_Generic
		public RuleCall getStatement_For_GenericParserRuleCall_5() { return cStatement_For_GenericParserRuleCall_5; }

		//Statement_GlobalFunction_Declaration
		public RuleCall getStatement_GlobalFunction_DeclarationParserRuleCall_6() { return cStatement_GlobalFunction_DeclarationParserRuleCall_6; }

		//Statement_LocalFunction_Declaration
		public RuleCall getStatement_LocalFunction_DeclarationParserRuleCall_7() { return cStatement_LocalFunction_DeclarationParserRuleCall_7; }

		//Statement_Local_Variable_Declaration
		public RuleCall getStatement_Local_Variable_DeclarationParserRuleCall_8() { return cStatement_Local_Variable_DeclarationParserRuleCall_8; }

		//Statement_FunctioncallOrAssignment
		public RuleCall getStatement_FunctioncallOrAssignmentParserRuleCall_9() { return cStatement_FunctioncallOrAssignmentParserRuleCall_9; }
	}

	public class Statement_BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// A block can be explicitly delimited to produce a single statement. "do ... end"
		//Statement_Block:
		//	"do" block=Block "end";
		@Override public ParserRule getRule() { return rule; }

		//"do" block=Block "end"
		public Group getGroup() { return cGroup; }

		//"do"
		public Keyword getDoKeyword_0() { return cDoKeyword_0; }

		//block=Block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }
	}

	public class Statement_WhileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_While");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhileKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpressionExpressionParserRuleCall_1_0 = (RuleCall)cExpressionAssignment_1.eContents().get(0);
		private final Keyword cDoKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBlockBlockParserRuleCall_3_0 = (RuleCall)cBlockAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// Control structure. "while ... do ... end"
		//Statement_While:
		//	"while" expression=Expression "do" block=Block "end";
		@Override public ParserRule getRule() { return rule; }

		//"while" expression=Expression "do" block=Block "end"
		public Group getGroup() { return cGroup; }

		//"while"
		public Keyword getWhileKeyword_0() { return cWhileKeyword_0; }

		//expression=Expression
		public Assignment getExpressionAssignment_1() { return cExpressionAssignment_1; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_1_0() { return cExpressionExpressionParserRuleCall_1_0; }

		//"do"
		public Keyword getDoKeyword_2() { return cDoKeyword_2; }

		//block=Block
		public Assignment getBlockAssignment_3() { return cBlockAssignment_3; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_3_0() { return cBlockBlockParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}

	public class Statement_RepeatElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_Repeat");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRepeatKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cBlockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBlockBlockParserRuleCall_1_0 = (RuleCall)cBlockAssignment_1.eContents().get(0);
		private final Keyword cUntilKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpressionExpressionParserRuleCall_3_0 = (RuleCall)cExpressionAssignment_3.eContents().get(0);
		
		//// Control structure. "repeat ... until ..."
		//Statement_Repeat:
		//	"repeat" block=Block "until" expression=Expression;
		@Override public ParserRule getRule() { return rule; }

		//"repeat" block=Block "until" expression=Expression
		public Group getGroup() { return cGroup; }

		//"repeat"
		public Keyword getRepeatKeyword_0() { return cRepeatKeyword_0; }

		//block=Block
		public Assignment getBlockAssignment_1() { return cBlockAssignment_1; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_1_0() { return cBlockBlockParserRuleCall_1_0; }

		//"until"
		public Keyword getUntilKeyword_2() { return cUntilKeyword_2; }

		//expression=Expression
		public Assignment getExpressionAssignment_3() { return cExpressionAssignment_3; }

		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_3_0() { return cExpressionExpressionParserRuleCall_3_0; }
	}

	public class Statement_If_Then_ElseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_If_Then_Else");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIfKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIfExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIfExpressionExpressionParserRuleCall_1_0 = (RuleCall)cIfExpressionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIfBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIfBlockBlockParserRuleCall_3_0 = (RuleCall)cIfBlockAssignment_3.eContents().get(0);
		private final Assignment cElseIfAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElseIfStatement_If_Then_Else_ElseIfPartParserRuleCall_4_0 = (RuleCall)cElseIfAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cElseKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cElseBlockAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cElseBlockBlockParserRuleCall_5_1_0 = (RuleCall)cElseBlockAssignment_5_1.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// Control structure. "if ... then ... elseif ... elseif ... else ... end"
		//Statement_If_Then_Else:
		//	"if" ifExpression=Expression "then" ifBlock=Block elseIf+=Statement_If_Then_Else_ElseIfPart* ("else" elseBlock=Block)?
		//	"end";
		@Override public ParserRule getRule() { return rule; }

		//"if" ifExpression=Expression "then" ifBlock=Block elseIf+=Statement_If_Then_Else_ElseIfPart* ("else" elseBlock=Block)?
		//"end"
		public Group getGroup() { return cGroup; }

		//"if"
		public Keyword getIfKeyword_0() { return cIfKeyword_0; }

		//ifExpression=Expression
		public Assignment getIfExpressionAssignment_1() { return cIfExpressionAssignment_1; }

		//Expression
		public RuleCall getIfExpressionExpressionParserRuleCall_1_0() { return cIfExpressionExpressionParserRuleCall_1_0; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }

		//ifBlock=Block
		public Assignment getIfBlockAssignment_3() { return cIfBlockAssignment_3; }

		//Block
		public RuleCall getIfBlockBlockParserRuleCall_3_0() { return cIfBlockBlockParserRuleCall_3_0; }

		//elseIf+=Statement_If_Then_Else_ElseIfPart*
		public Assignment getElseIfAssignment_4() { return cElseIfAssignment_4; }

		//Statement_If_Then_Else_ElseIfPart
		public RuleCall getElseIfStatement_If_Then_Else_ElseIfPartParserRuleCall_4_0() { return cElseIfStatement_If_Then_Else_ElseIfPartParserRuleCall_4_0; }

		//("else" elseBlock=Block)?
		public Group getGroup_5() { return cGroup_5; }

		//"else"
		public Keyword getElseKeyword_5_0() { return cElseKeyword_5_0; }

		//elseBlock=Block
		public Assignment getElseBlockAssignment_5_1() { return cElseBlockAssignment_5_1; }

		//Block
		public RuleCall getElseBlockBlockParserRuleCall_5_1_0() { return cElseBlockBlockParserRuleCall_5_1_0; }

		//"end"
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}

	public class Statement_If_Then_Else_ElseIfPartElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_If_Then_Else_ElseIfPart");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cElseifKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cElseifExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElseifExpressionExpressionParserRuleCall_1_0 = (RuleCall)cElseifExpressionAssignment_1.eContents().get(0);
		private final Keyword cThenKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cElseifBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cElseifBlockBlockParserRuleCall_3_0 = (RuleCall)cElseifBlockAssignment_3.eContents().get(0);
		
		//Statement_If_Then_Else_ElseIfPart:
		//	"elseif" elseifExpression=Expression "then" elseifBlock=Block;
		@Override public ParserRule getRule() { return rule; }

		//"elseif" elseifExpression=Expression "then" elseifBlock=Block
		public Group getGroup() { return cGroup; }

		//"elseif"
		public Keyword getElseifKeyword_0() { return cElseifKeyword_0; }

		//elseifExpression=Expression
		public Assignment getElseifExpressionAssignment_1() { return cElseifExpressionAssignment_1; }

		//Expression
		public RuleCall getElseifExpressionExpressionParserRuleCall_1_0() { return cElseifExpressionExpressionParserRuleCall_1_0; }

		//"then"
		public Keyword getThenKeyword_2() { return cThenKeyword_2; }

		//elseifBlock=Block
		public Assignment getElseifBlockAssignment_3() { return cElseifBlockAssignment_3; }

		//Block
		public RuleCall getElseifBlockBlockParserRuleCall_3_0() { return cElseifBlockBlockParserRuleCall_3_0; }
	}

	public class Statement_For_NumericElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_For_Numeric");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIteratorNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIteratorNameLUA_NAMETerminalRuleCall_1_0 = (RuleCall)cIteratorNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStartExprAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cStartExprExpressionParserRuleCall_3_0 = (RuleCall)cStartExprAssignment_3.eContents().get(0);
		private final Keyword cCommaKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cUntilExprAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cUntilExprExpressionParserRuleCall_5_0 = (RuleCall)cUntilExprAssignment_5.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cCommaKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cStepExprAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cStepExprExpressionParserRuleCall_6_1_0 = (RuleCall)cStepExprAssignment_6_1.eContents().get(0);
		private final Keyword cDoKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cBlockAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cBlockBlockParserRuleCall_8_0 = (RuleCall)cBlockAssignment_8.eContents().get(0);
		private final Keyword cEndKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//// The numeric for loop repeats a block of code while a control variable runs through an arithmetic progression "for ...=..., ... [,...] do ... end"
		//Statement_For_Numeric:
		//	"for" iteratorName=LUA_NAME "=" startExpr=Expression "," untilExpr=Expression ("," stepExpr=Expression)? "do"
		//	block=Block "end";
		@Override public ParserRule getRule() { return rule; }

		//"for" iteratorName=LUA_NAME "=" startExpr=Expression "," untilExpr=Expression ("," stepExpr=Expression)? "do"
		//block=Block "end"
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//iteratorName=LUA_NAME
		public Assignment getIteratorNameAssignment_1() { return cIteratorNameAssignment_1; }

		//LUA_NAME
		public RuleCall getIteratorNameLUA_NAMETerminalRuleCall_1_0() { return cIteratorNameLUA_NAMETerminalRuleCall_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//startExpr=Expression
		public Assignment getStartExprAssignment_3() { return cStartExprAssignment_3; }

		//Expression
		public RuleCall getStartExprExpressionParserRuleCall_3_0() { return cStartExprExpressionParserRuleCall_3_0; }

		//","
		public Keyword getCommaKeyword_4() { return cCommaKeyword_4; }

		//untilExpr=Expression
		public Assignment getUntilExprAssignment_5() { return cUntilExprAssignment_5; }

		//Expression
		public RuleCall getUntilExprExpressionParserRuleCall_5_0() { return cUntilExprExpressionParserRuleCall_5_0; }

		//("," stepExpr=Expression)?
		public Group getGroup_6() { return cGroup_6; }

		//","
		public Keyword getCommaKeyword_6_0() { return cCommaKeyword_6_0; }

		//stepExpr=Expression
		public Assignment getStepExprAssignment_6_1() { return cStepExprAssignment_6_1; }

		//Expression
		public RuleCall getStepExprExpressionParserRuleCall_6_1_0() { return cStepExprExpressionParserRuleCall_6_1_0; }

		//"do"
		public Keyword getDoKeyword_7() { return cDoKeyword_7; }

		//block=Block
		public Assignment getBlockAssignment_8() { return cBlockAssignment_8; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_8_0() { return cBlockBlockParserRuleCall_8_0; }

		//"end"
		public Keyword getEndKeyword_9() { return cEndKeyword_9; }
	}

	public class Statement_For_GenericElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_For_Generic");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNamesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNamesLUA_NAMETerminalRuleCall_1_0 = (RuleCall)cNamesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cNamesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cNamesLUA_NAMETerminalRuleCall_2_1_0 = (RuleCall)cNamesAssignment_2_1.eContents().get(0);
		private final Keyword cInKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cExpressionsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExpressionsExpressionParserRuleCall_4_0 = (RuleCall)cExpressionsAssignment_4.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCommaKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cExpressionsAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cExpressionsExpressionParserRuleCall_5_1_0 = (RuleCall)cExpressionsAssignment_5_1.eContents().get(0);
		private final Keyword cDoKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBlockAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cBlockBlockParserRuleCall_7_0 = (RuleCall)cBlockAssignment_7.eContents().get(0);
		private final Keyword cEndKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//// The generic for statement works over functions, called iterators. On each iteration, the iterator function is called to produce a new value, stopping when this new value is nil "for ... in ... do ... end"
		//Statement_For_Generic:
		//	"for" names+=LUA_NAME ("," names+=LUA_NAME)* "in" expressions+=Expression ("," expressions+=Expression)* "do"
		//	block=Block "end";
		@Override public ParserRule getRule() { return rule; }

		//"for" names+=LUA_NAME ("," names+=LUA_NAME)* "in" expressions+=Expression ("," expressions+=Expression)* "do"
		//block=Block "end"
		public Group getGroup() { return cGroup; }

		//"for"
		public Keyword getForKeyword_0() { return cForKeyword_0; }

		//names+=LUA_NAME
		public Assignment getNamesAssignment_1() { return cNamesAssignment_1; }

		//LUA_NAME
		public RuleCall getNamesLUA_NAMETerminalRuleCall_1_0() { return cNamesLUA_NAMETerminalRuleCall_1_0; }

		//("," names+=LUA_NAME)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//names+=LUA_NAME
		public Assignment getNamesAssignment_2_1() { return cNamesAssignment_2_1; }

		//LUA_NAME
		public RuleCall getNamesLUA_NAMETerminalRuleCall_2_1_0() { return cNamesLUA_NAMETerminalRuleCall_2_1_0; }

		//"in"
		public Keyword getInKeyword_3() { return cInKeyword_3; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_4() { return cExpressionsAssignment_4; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_4_0() { return cExpressionsExpressionParserRuleCall_4_0; }

		//("," expressions+=Expression)*
		public Group getGroup_5() { return cGroup_5; }

		//","
		public Keyword getCommaKeyword_5_0() { return cCommaKeyword_5_0; }

		//expressions+=Expression
		public Assignment getExpressionsAssignment_5_1() { return cExpressionsAssignment_5_1; }

		//Expression
		public RuleCall getExpressionsExpressionParserRuleCall_5_1_0() { return cExpressionsExpressionParserRuleCall_5_1_0; }

		//"do"
		public Keyword getDoKeyword_6() { return cDoKeyword_6; }

		//block=Block
		public Assignment getBlockAssignment_7() { return cBlockAssignment_7; }

		//Block
		public RuleCall getBlockBlockParserRuleCall_7_0() { return cBlockBlockParserRuleCall_7_0; }

		//"end"
		public Keyword getEndKeyword_8() { return cEndKeyword_8; }
	}

	public class Statement_GlobalFunction_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_GlobalFunction_Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPrefixAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPrefixLUA_NAMETerminalRuleCall_1_0 = (RuleCall)cPrefixAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cPrefixAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cPrefixLUA_NAMETerminalRuleCall_2_1_0 = (RuleCall)cPrefixAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cColonKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cFunctionNameAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cFunctionNameLUA_NAMETerminalRuleCall_3_1_0 = (RuleCall)cFunctionNameAssignment_3_1.eContents().get(0);
		private final Assignment cFunctionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFunctionFunctionParserRuleCall_4_0 = (RuleCall)cFunctionAssignment_4.eContents().get(0);
		private final Keyword cEndKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Statement_GlobalFunction_Declaration:
		//	"function" prefix+=LUA_NAME ("." prefix+=LUA_NAME)* (":" functionName=LUA_NAME)? function=Function "end";
		@Override public ParserRule getRule() { return rule; }

		//"function" prefix+=LUA_NAME ("." prefix+=LUA_NAME)* (":" functionName=LUA_NAME)? function=Function "end"
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//prefix+=LUA_NAME
		public Assignment getPrefixAssignment_1() { return cPrefixAssignment_1; }

		//LUA_NAME
		public RuleCall getPrefixLUA_NAMETerminalRuleCall_1_0() { return cPrefixLUA_NAMETerminalRuleCall_1_0; }

		//("." prefix+=LUA_NAME)*
		public Group getGroup_2() { return cGroup_2; }

		//"."
		public Keyword getFullStopKeyword_2_0() { return cFullStopKeyword_2_0; }

		//prefix+=LUA_NAME
		public Assignment getPrefixAssignment_2_1() { return cPrefixAssignment_2_1; }

		//LUA_NAME
		public RuleCall getPrefixLUA_NAMETerminalRuleCall_2_1_0() { return cPrefixLUA_NAMETerminalRuleCall_2_1_0; }

		//(":" functionName=LUA_NAME)?
		public Group getGroup_3() { return cGroup_3; }

		//":"
		public Keyword getColonKeyword_3_0() { return cColonKeyword_3_0; }

		//functionName=LUA_NAME
		public Assignment getFunctionNameAssignment_3_1() { return cFunctionNameAssignment_3_1; }

		//LUA_NAME
		public RuleCall getFunctionNameLUA_NAMETerminalRuleCall_3_1_0() { return cFunctionNameLUA_NAMETerminalRuleCall_3_1_0; }

		//function=Function
		public Assignment getFunctionAssignment_4() { return cFunctionAssignment_4; }

		//Function
		public RuleCall getFunctionFunctionParserRuleCall_4_0() { return cFunctionFunctionParserRuleCall_4_0; }

		//"end"
		public Keyword getEndKeyword_5() { return cEndKeyword_5; }
	}

	public class Statement_LocalFunction_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_LocalFunction_Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLocalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cFunctionKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cFunctionNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFunctionNameLUA_NAMETerminalRuleCall_2_0 = (RuleCall)cFunctionNameAssignment_2.eContents().get(0);
		private final Assignment cFunctionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFunctionFunctionParserRuleCall_3_0 = (RuleCall)cFunctionAssignment_3.eContents().get(0);
		private final Keyword cEndKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//Statement_LocalFunction_Declaration:
		//	"local" "function" functionName=LUA_NAME function=Function "end";
		@Override public ParserRule getRule() { return rule; }

		//"local" "function" functionName=LUA_NAME function=Function "end"
		public Group getGroup() { return cGroup; }

		//"local"
		public Keyword getLocalKeyword_0() { return cLocalKeyword_0; }

		//"function"
		public Keyword getFunctionKeyword_1() { return cFunctionKeyword_1; }

		//functionName=LUA_NAME
		public Assignment getFunctionNameAssignment_2() { return cFunctionNameAssignment_2; }

		//LUA_NAME
		public RuleCall getFunctionNameLUA_NAMETerminalRuleCall_2_0() { return cFunctionNameLUA_NAMETerminalRuleCall_2_0; }

		//function=Function
		public Assignment getFunctionAssignment_3() { return cFunctionAssignment_3; }

		//Function
		public RuleCall getFunctionFunctionParserRuleCall_3_0() { return cFunctionFunctionParserRuleCall_3_0; }

		//"end"
		public Keyword getEndKeyword_4() { return cEndKeyword_4; }
	}

	public class Statement_Local_Variable_DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_Local_Variable_Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLocalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cVariableNamesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableNamesLUA_NAMETerminalRuleCall_1_0 = (RuleCall)cVariableNamesAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cVariableNamesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cVariableNamesLUA_NAMETerminalRuleCall_2_1_0 = (RuleCall)cVariableNamesAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cEqualsSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cInitialValueAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cInitialValueExpressionParserRuleCall_3_1_0 = (RuleCall)cInitialValueAssignment_3_1.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cGroup_3.eContents().get(2);
		private final Keyword cCommaKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Assignment cInitialValueAssignment_3_2_1 = (Assignment)cGroup_3_2.eContents().get(1);
		private final RuleCall cInitialValueExpressionParserRuleCall_3_2_1_0 = (RuleCall)cInitialValueAssignment_3_2_1.eContents().get(0);
		
		//// Local variables can be declared anywhere inside a block. The declaration can include an initial assignment "local ... [= ...]"
		//Statement_Local_Variable_Declaration:
		//	"local" variableNames+=LUA_NAME ("," variableNames+=LUA_NAME)* ("=" initialValue+=Expression (","
		//	initialValue+=Expression)*)?;
		@Override public ParserRule getRule() { return rule; }

		//"local" variableNames+=LUA_NAME ("," variableNames+=LUA_NAME)* ("=" initialValue+=Expression (","
		//initialValue+=Expression)*)?
		public Group getGroup() { return cGroup; }

		//"local"
		public Keyword getLocalKeyword_0() { return cLocalKeyword_0; }

		//variableNames+=LUA_NAME
		public Assignment getVariableNamesAssignment_1() { return cVariableNamesAssignment_1; }

		//LUA_NAME
		public RuleCall getVariableNamesLUA_NAMETerminalRuleCall_1_0() { return cVariableNamesLUA_NAMETerminalRuleCall_1_0; }

		//("," variableNames+=LUA_NAME)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//variableNames+=LUA_NAME
		public Assignment getVariableNamesAssignment_2_1() { return cVariableNamesAssignment_2_1; }

		//LUA_NAME
		public RuleCall getVariableNamesLUA_NAMETerminalRuleCall_2_1_0() { return cVariableNamesLUA_NAMETerminalRuleCall_2_1_0; }

		//("=" initialValue+=Expression ("," initialValue+=Expression)*)?
		public Group getGroup_3() { return cGroup_3; }

		//"="
		public Keyword getEqualsSignKeyword_3_0() { return cEqualsSignKeyword_3_0; }

		//initialValue+=Expression
		public Assignment getInitialValueAssignment_3_1() { return cInitialValueAssignment_3_1; }

		//Expression
		public RuleCall getInitialValueExpressionParserRuleCall_3_1_0() { return cInitialValueExpressionParserRuleCall_3_1_0; }

		//("," initialValue+=Expression)*
		public Group getGroup_3_2() { return cGroup_3_2; }

		//","
		public Keyword getCommaKeyword_3_2_0() { return cCommaKeyword_3_2_0; }

		//initialValue+=Expression
		public Assignment getInitialValueAssignment_3_2_1() { return cInitialValueAssignment_3_2_1; }

		//Expression
		public RuleCall getInitialValueExpressionParserRuleCall_3_2_1_0() { return cInitialValueExpressionParserRuleCall_3_2_1_0; }
	}

	public class Statement_FunctioncallOrAssignmentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement_FunctioncallOrAssignment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_AccessMemberOrArrayElementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Action cStatement_AssignmentVariableAction_1_0_0 = (Action)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Keyword cCommaKeyword_1_0_1_0 = (Keyword)cGroup_1_0_1.eContents().get(0);
		private final Assignment cVariableAssignment_1_0_1_1 = (Assignment)cGroup_1_0_1.eContents().get(1);
		private final RuleCall cVariableExpression_AccessMemberOrArrayElementParserRuleCall_1_0_1_1_0 = (RuleCall)cVariableAssignment_1_0_1_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1_0_2 = (Keyword)cGroup_1_0.eContents().get(2);
		private final Assignment cValuesAssignment_1_0_3 = (Assignment)cGroup_1_0.eContents().get(3);
		private final RuleCall cValuesExpressionParserRuleCall_1_0_3_0 = (RuleCall)cValuesAssignment_1_0_3.eContents().get(0);
		private final Group cGroup_1_0_4 = (Group)cGroup_1_0.eContents().get(4);
		private final Keyword cCommaKeyword_1_0_4_0 = (Keyword)cGroup_1_0_4.eContents().get(0);
		private final Assignment cValuesAssignment_1_0_4_1 = (Assignment)cGroup_1_0_4.eContents().get(1);
		private final RuleCall cValuesExpressionParserRuleCall_1_0_4_1_0 = (RuleCall)cValuesAssignment_1_0_4_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cColonKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Action cStatement_CallMemberFunctionObjectAction_1_1_1 = (Action)cGroup_1_1.eContents().get(1);
		private final Assignment cMemberFunctionNameAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cMemberFunctionNameLUA_NAMETerminalRuleCall_1_1_2_0 = (RuleCall)cMemberFunctionNameAssignment_1_1_2.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_1_3 = (Assignment)cGroup_1_1.eContents().get(3);
		private final RuleCall cArgumentsFunctioncall_ArgumentsParserRuleCall_1_1_3_0 = (RuleCall)cArgumentsAssignment_1_1_3.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Action cStatement_CallFunctionObjectAction_1_2_0 = (Action)cGroup_1_2.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_2_1 = (Assignment)cGroup_1_2.eContents().get(1);
		private final RuleCall cArgumentsFunctioncall_ArgumentsParserRuleCall_1_2_1_0 = (RuleCall)cArgumentsAssignment_1_2_1.eContents().get(0);
		
		//Statement_FunctioncallOrAssignment:
		//	Expression_AccessMemberOrArrayElement ({Statement_Assignment.variable+=current} (","
		//	variable+=Expression_AccessMemberOrArrayElement)* "=" values+=Expression ("," values+=Expression)* // Assignment
		//	// Call of a member function
		//	// Call of a function pointer
		//	| ":" {Statement_CallMemberFunction.object=current} memberFunctionName=LUA_NAME arguments=Functioncall_Arguments |
		//	{Statement_CallFunction.object=current} arguments=Functioncall_Arguments);
		@Override public ParserRule getRule() { return rule; }

		//Expression_AccessMemberOrArrayElement ({Statement_Assignment.variable+=current} (","
		//variable+=Expression_AccessMemberOrArrayElement)* "=" values+=Expression ("," values+=Expression)* // Assignment
		//// Call of a member function
		//// Call of a function pointer
		//| ":" {Statement_CallMemberFunction.object=current} memberFunctionName=LUA_NAME arguments=Functioncall_Arguments |
		//{Statement_CallFunction.object=current} arguments=Functioncall_Arguments)
		public Group getGroup() { return cGroup; }

		//Expression_AccessMemberOrArrayElement
		public RuleCall getExpression_AccessMemberOrArrayElementParserRuleCall_0() { return cExpression_AccessMemberOrArrayElementParserRuleCall_0; }

		//{Statement_Assignment.variable+=current} ("," variable+=Expression_AccessMemberOrArrayElement)* "=" values+=Expression
		//("," values+=Expression)* // Assignment
		//// Call of a member function
		//// Call of a function pointer
		//| ":" {Statement_CallMemberFunction.object=current} memberFunctionName=LUA_NAME arguments=Functioncall_Arguments |
		//{Statement_CallFunction.object=current} arguments=Functioncall_Arguments
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//{Statement_Assignment.variable+=current} ("," variable+=Expression_AccessMemberOrArrayElement)* "=" values+=Expression
		//("," values+=Expression)*
		public Group getGroup_1_0() { return cGroup_1_0; }

		//{Statement_Assignment.variable+=current}
		public Action getStatement_AssignmentVariableAction_1_0_0() { return cStatement_AssignmentVariableAction_1_0_0; }

		//(=> "," variable+=Expression_AccessMemberOrArrayElement)*
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//=> ","
		public Keyword getCommaKeyword_1_0_1_0() { return cCommaKeyword_1_0_1_0; }

		//variable+=Expression_AccessMemberOrArrayElement
		public Assignment getVariableAssignment_1_0_1_1() { return cVariableAssignment_1_0_1_1; }

		//Expression_AccessMemberOrArrayElement
		public RuleCall getVariableExpression_AccessMemberOrArrayElementParserRuleCall_1_0_1_1_0() { return cVariableExpression_AccessMemberOrArrayElementParserRuleCall_1_0_1_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_1_0_2() { return cEqualsSignKeyword_1_0_2; }

		//values+=Expression
		public Assignment getValuesAssignment_1_0_3() { return cValuesAssignment_1_0_3; }

		//Expression
		public RuleCall getValuesExpressionParserRuleCall_1_0_3_0() { return cValuesExpressionParserRuleCall_1_0_3_0; }

		//("," values+=Expression)*
		public Group getGroup_1_0_4() { return cGroup_1_0_4; }

		//","
		public Keyword getCommaKeyword_1_0_4_0() { return cCommaKeyword_1_0_4_0; }

		//values+=Expression
		public Assignment getValuesAssignment_1_0_4_1() { return cValuesAssignment_1_0_4_1; }

		//Expression
		public RuleCall getValuesExpressionParserRuleCall_1_0_4_1_0() { return cValuesExpressionParserRuleCall_1_0_4_1_0; }

		//":" {Statement_CallMemberFunction.object=current} memberFunctionName=LUA_NAME arguments=Functioncall_Arguments
		public Group getGroup_1_1() { return cGroup_1_1; }

		//":"
		public Keyword getColonKeyword_1_1_0() { return cColonKeyword_1_1_0; }

		//{Statement_CallMemberFunction.object=current}
		public Action getStatement_CallMemberFunctionObjectAction_1_1_1() { return cStatement_CallMemberFunctionObjectAction_1_1_1; }

		//memberFunctionName=LUA_NAME
		public Assignment getMemberFunctionNameAssignment_1_1_2() { return cMemberFunctionNameAssignment_1_1_2; }

		//LUA_NAME
		public RuleCall getMemberFunctionNameLUA_NAMETerminalRuleCall_1_1_2_0() { return cMemberFunctionNameLUA_NAMETerminalRuleCall_1_1_2_0; }

		//arguments=Functioncall_Arguments
		public Assignment getArgumentsAssignment_1_1_3() { return cArgumentsAssignment_1_1_3; }

		//Functioncall_Arguments
		public RuleCall getArgumentsFunctioncall_ArgumentsParserRuleCall_1_1_3_0() { return cArgumentsFunctioncall_ArgumentsParserRuleCall_1_1_3_0; }

		//{Statement_CallFunction.object=current} arguments=Functioncall_Arguments
		public Group getGroup_1_2() { return cGroup_1_2; }

		//{Statement_CallFunction.object=current}
		public Action getStatement_CallFunctionObjectAction_1_2_0() { return cStatement_CallFunctionObjectAction_1_2_0; }

		//arguments=Functioncall_Arguments
		public Assignment getArgumentsAssignment_1_2_1() { return cArgumentsAssignment_1_2_1; }

		//Functioncall_Arguments
		public RuleCall getArgumentsFunctioncall_ArgumentsParserRuleCall_1_2_1_0() { return cArgumentsFunctioncall_ArgumentsParserRuleCall_1_2_1_0; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression");
		private final RuleCall cExpression_OrParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// ****************************************************
		//// EXPRESSIONS
		//// ****************************************************
		//// Delegate to the priority chain of operators by calling the rule for the lowest priority operator
		//Expression hidden(WS, COMMENT):
		//	Expression_Or;
		@Override public ParserRule getRule() { return rule; }

		//Expression_Or
		public RuleCall getExpression_OrParserRuleCall() { return cExpression_OrParserRuleCall; }
	}

	public class Expression_OrElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Or");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_AndParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cOrKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cExpression_OrLeftAction_1_1 = (Action)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpression_AndParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// Or: left associative, priority 0
		//Expression_Or returns Expression:
		//	Expression_And ("or" {Expression_Or.left=current} right=Expression_And)*;
		@Override public ParserRule getRule() { return rule; }

		//Expression_And ("or" {Expression_Or.left=current} right=Expression_And)*
		public Group getGroup() { return cGroup; }

		//Expression_And
		public RuleCall getExpression_AndParserRuleCall_0() { return cExpression_AndParserRuleCall_0; }

		//("or" {Expression_Or.left=current} right=Expression_And)*
		public Group getGroup_1() { return cGroup_1; }

		//"or"
		public Keyword getOrKeyword_1_0() { return cOrKeyword_1_0; }

		//{Expression_Or.left=current}
		public Action getExpression_OrLeftAction_1_1() { return cExpression_OrLeftAction_1_1; }

		//right=Expression_And
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Expression_And
		public RuleCall getRightExpression_AndParserRuleCall_1_2_0() { return cRightExpression_AndParserRuleCall_1_2_0; }
	}

	public class Expression_AndElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_And");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_CompareParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cAndKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cExpression_AndLeftAction_1_1 = (Action)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpression_CompareParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// And: left associative, priority 1
		//Expression_And returns Expression:
		//	Expression_Compare ("and" {Expression_And.left=current} right=Expression_Compare)*;
		@Override public ParserRule getRule() { return rule; }

		//Expression_Compare ("and" {Expression_And.left=current} right=Expression_Compare)*
		public Group getGroup() { return cGroup; }

		//Expression_Compare
		public RuleCall getExpression_CompareParserRuleCall_0() { return cExpression_CompareParserRuleCall_0; }

		//("and" {Expression_And.left=current} right=Expression_Compare)*
		public Group getGroup_1() { return cGroup_1; }

		//"and"
		public Keyword getAndKeyword_1_0() { return cAndKeyword_1_0; }

		//{Expression_And.left=current}
		public Action getExpression_AndLeftAction_1_1() { return cExpression_AndLeftAction_1_1; }

		//right=Expression_Compare
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Expression_Compare
		public RuleCall getRightExpression_CompareParserRuleCall_1_2_0() { return cRightExpression_CompareParserRuleCall_1_2_0; }
	}

	public class Expression_CompareElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Compare");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_ConcatenationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Action cExpression_LargerLeftAction_1_0_1 = (Action)cGroup_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightExpression_ConcatenationParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Action cExpression_Larger_EqualLeftAction_1_1_1 = (Action)cGroup_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightExpression_ConcatenationParserRuleCall_1_1_2_0 = (RuleCall)cRightAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Keyword cLessThanSignKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Action cExpression_SmallerLeftAction_1_2_1 = (Action)cGroup_1_2.eContents().get(1);
		private final Assignment cRightAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cRightExpression_ConcatenationParserRuleCall_1_2_2_0 = (RuleCall)cRightAssignment_1_2_2.eContents().get(0);
		private final Group cGroup_1_3 = (Group)cAlternatives_1.eContents().get(3);
		private final Keyword cLessThanSignEqualsSignKeyword_1_3_0 = (Keyword)cGroup_1_3.eContents().get(0);
		private final Action cExpression_Smaller_EqualLeftAction_1_3_1 = (Action)cGroup_1_3.eContents().get(1);
		private final Assignment cRightAssignment_1_3_2 = (Assignment)cGroup_1_3.eContents().get(2);
		private final RuleCall cRightExpression_ConcatenationParserRuleCall_1_3_2_0 = (RuleCall)cRightAssignment_1_3_2.eContents().get(0);
		private final Group cGroup_1_4 = (Group)cAlternatives_1.eContents().get(4);
		private final Keyword cEqualsSignEqualsSignKeyword_1_4_0 = (Keyword)cGroup_1_4.eContents().get(0);
		private final Action cExpression_EqualLeftAction_1_4_1 = (Action)cGroup_1_4.eContents().get(1);
		private final Assignment cRightAssignment_1_4_2 = (Assignment)cGroup_1_4.eContents().get(2);
		private final RuleCall cRightExpression_ConcatenationParserRuleCall_1_4_2_0 = (RuleCall)cRightAssignment_1_4_2.eContents().get(0);
		private final Group cGroup_1_5 = (Group)cAlternatives_1.eContents().get(5);
		private final Keyword cTildeEqualsSignKeyword_1_5_0 = (Keyword)cGroup_1_5.eContents().get(0);
		private final Action cExpression_Not_EqualLeftAction_1_5_1 = (Action)cGroup_1_5.eContents().get(1);
		private final Assignment cRightAssignment_1_5_2 = (Assignment)cGroup_1_5.eContents().get(2);
		private final RuleCall cRightExpression_ConcatenationParserRuleCall_1_5_2_0 = (RuleCall)cRightAssignment_1_5_2.eContents().get(0);
		
		//// Comparisons: left associative, priority 2
		//Expression_Compare returns Expression:
		//	Expression_Concatenation (">" {Expression_Larger.left=current} right=Expression_Concatenation | ">="
		//	{Expression_Larger_Equal.left=current} right=Expression_Concatenation | "<" {Expression_Smaller.left=current}
		//	right=Expression_Concatenation | "<=" {Expression_Smaller_Equal.left=current} right=Expression_Concatenation | "=="
		//	{Expression_Equal.left=current} right=Expression_Concatenation | "~=" {Expression_Not_Equal.left=current}
		//	right=Expression_Concatenation)*;
		@Override public ParserRule getRule() { return rule; }

		//Expression_Concatenation (">" {Expression_Larger.left=current} right=Expression_Concatenation | ">="
		//{Expression_Larger_Equal.left=current} right=Expression_Concatenation | "<" {Expression_Smaller.left=current}
		//right=Expression_Concatenation | "<=" {Expression_Smaller_Equal.left=current} right=Expression_Concatenation | "=="
		//{Expression_Equal.left=current} right=Expression_Concatenation | "~=" {Expression_Not_Equal.left=current}
		//right=Expression_Concatenation)*
		public Group getGroup() { return cGroup; }

		//Expression_Concatenation
		public RuleCall getExpression_ConcatenationParserRuleCall_0() { return cExpression_ConcatenationParserRuleCall_0; }

		//(">" {Expression_Larger.left=current} right=Expression_Concatenation | ">=" {Expression_Larger_Equal.left=current}
		//right=Expression_Concatenation | "<" {Expression_Smaller.left=current} right=Expression_Concatenation | "<="
		//{Expression_Smaller_Equal.left=current} right=Expression_Concatenation | "==" {Expression_Equal.left=current}
		//right=Expression_Concatenation | "~=" {Expression_Not_Equal.left=current} right=Expression_Concatenation)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//">" {Expression_Larger.left=current} right=Expression_Concatenation
		public Group getGroup_1_0() { return cGroup_1_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_0_0() { return cGreaterThanSignKeyword_1_0_0; }

		//{Expression_Larger.left=current}
		public Action getExpression_LargerLeftAction_1_0_1() { return cExpression_LargerLeftAction_1_0_1; }

		//right=Expression_Concatenation
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//Expression_Concatenation
		public RuleCall getRightExpression_ConcatenationParserRuleCall_1_0_2_0() { return cRightExpression_ConcatenationParserRuleCall_1_0_2_0; }

		//">=" {Expression_Larger_Equal.left=current} right=Expression_Concatenation
		public Group getGroup_1_1() { return cGroup_1_1; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_1_1_0() { return cGreaterThanSignEqualsSignKeyword_1_1_0; }

		//{Expression_Larger_Equal.left=current}
		public Action getExpression_Larger_EqualLeftAction_1_1_1() { return cExpression_Larger_EqualLeftAction_1_1_1; }

		//right=Expression_Concatenation
		public Assignment getRightAssignment_1_1_2() { return cRightAssignment_1_1_2; }

		//Expression_Concatenation
		public RuleCall getRightExpression_ConcatenationParserRuleCall_1_1_2_0() { return cRightExpression_ConcatenationParserRuleCall_1_1_2_0; }

		//"<" {Expression_Smaller.left=current} right=Expression_Concatenation
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"<"
		public Keyword getLessThanSignKeyword_1_2_0() { return cLessThanSignKeyword_1_2_0; }

		//{Expression_Smaller.left=current}
		public Action getExpression_SmallerLeftAction_1_2_1() { return cExpression_SmallerLeftAction_1_2_1; }

		//right=Expression_Concatenation
		public Assignment getRightAssignment_1_2_2() { return cRightAssignment_1_2_2; }

		//Expression_Concatenation
		public RuleCall getRightExpression_ConcatenationParserRuleCall_1_2_2_0() { return cRightExpression_ConcatenationParserRuleCall_1_2_2_0; }

		//"<=" {Expression_Smaller_Equal.left=current} right=Expression_Concatenation
		public Group getGroup_1_3() { return cGroup_1_3; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1_3_0() { return cLessThanSignEqualsSignKeyword_1_3_0; }

		//{Expression_Smaller_Equal.left=current}
		public Action getExpression_Smaller_EqualLeftAction_1_3_1() { return cExpression_Smaller_EqualLeftAction_1_3_1; }

		//right=Expression_Concatenation
		public Assignment getRightAssignment_1_3_2() { return cRightAssignment_1_3_2; }

		//Expression_Concatenation
		public RuleCall getRightExpression_ConcatenationParserRuleCall_1_3_2_0() { return cRightExpression_ConcatenationParserRuleCall_1_3_2_0; }

		//"==" {Expression_Equal.left=current} right=Expression_Concatenation
		public Group getGroup_1_4() { return cGroup_1_4; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_1_4_0() { return cEqualsSignEqualsSignKeyword_1_4_0; }

		//{Expression_Equal.left=current}
		public Action getExpression_EqualLeftAction_1_4_1() { return cExpression_EqualLeftAction_1_4_1; }

		//right=Expression_Concatenation
		public Assignment getRightAssignment_1_4_2() { return cRightAssignment_1_4_2; }

		//Expression_Concatenation
		public RuleCall getRightExpression_ConcatenationParserRuleCall_1_4_2_0() { return cRightExpression_ConcatenationParserRuleCall_1_4_2_0; }

		//"~=" {Expression_Not_Equal.left=current} right=Expression_Concatenation
		public Group getGroup_1_5() { return cGroup_1_5; }

		//"~="
		public Keyword getTildeEqualsSignKeyword_1_5_0() { return cTildeEqualsSignKeyword_1_5_0; }

		//{Expression_Not_Equal.left=current}
		public Action getExpression_Not_EqualLeftAction_1_5_1() { return cExpression_Not_EqualLeftAction_1_5_1; }

		//right=Expression_Concatenation
		public Assignment getRightAssignment_1_5_2() { return cRightAssignment_1_5_2; }

		//Expression_Concatenation
		public RuleCall getRightExpression_ConcatenationParserRuleCall_1_5_2_0() { return cRightExpression_ConcatenationParserRuleCall_1_5_2_0; }
	}

	public class Expression_ConcatenationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Concatenation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_PlusMinusParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cExpression_ConcatenationLeftAction_1_1 = (Action)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpression_ConcatenationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// Concatenation: right associative, priority 3
		//Expression_Concatenation returns Expression:
		//	Expression_PlusMinus (".." {Expression_Concatenation.left=current} right=Expression_Concatenation)?;
		@Override public ParserRule getRule() { return rule; }

		//Expression_PlusMinus (".." {Expression_Concatenation.left=current} right=Expression_Concatenation)?
		public Group getGroup() { return cGroup; }

		//Expression_PlusMinus
		public RuleCall getExpression_PlusMinusParserRuleCall_0() { return cExpression_PlusMinusParserRuleCall_0; }

		//(".." {Expression_Concatenation.left=current} right=Expression_Concatenation)?
		public Group getGroup_1() { return cGroup_1; }

		//".."
		public Keyword getFullStopFullStopKeyword_1_0() { return cFullStopFullStopKeyword_1_0; }

		//{Expression_Concatenation.left=current}
		public Action getExpression_ConcatenationLeftAction_1_1() { return cExpression_ConcatenationLeftAction_1_1; }

		//right=Expression_Concatenation
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Expression_Concatenation
		public RuleCall getRightExpression_ConcatenationParserRuleCall_1_2_0() { return cRightExpression_ConcatenationParserRuleCall_1_2_0; }
	}

	public class Expression_PlusMinusElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_PlusMinus");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_MultiplicationDivisionModuloParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Action cExpression_PlusLeftAction_1_0_1 = (Action)cGroup_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightExpression_MultiplicationDivisionModuloParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Action cExpression_MinusLeftAction_1_1_1 = (Action)cGroup_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightExpression_MultiplicationDivisionModuloParserRuleCall_1_1_2_0 = (RuleCall)cRightAssignment_1_1_2.eContents().get(0);
		
		//// addition/subtraction: left associative, priority 4
		//Expression_PlusMinus returns Expression:
		//	Expression_MultiplicationDivisionModulo ("+" {Expression_Plus.left=current}
		//	right=Expression_MultiplicationDivisionModulo | "-" {Expression_Minus.left=current}
		//	right=Expression_MultiplicationDivisionModulo)*;
		@Override public ParserRule getRule() { return rule; }

		//Expression_MultiplicationDivisionModulo ("+" {Expression_Plus.left=current}
		//right=Expression_MultiplicationDivisionModulo | "-" {Expression_Minus.left=current}
		//right=Expression_MultiplicationDivisionModulo)*
		public Group getGroup() { return cGroup; }

		//Expression_MultiplicationDivisionModulo
		public RuleCall getExpression_MultiplicationDivisionModuloParserRuleCall_0() { return cExpression_MultiplicationDivisionModuloParserRuleCall_0; }

		//("+" {Expression_Plus.left=current} right=Expression_MultiplicationDivisionModulo | "-" {Expression_Minus.left=current}
		//right=Expression_MultiplicationDivisionModulo)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"+" {Expression_Plus.left=current} right=Expression_MultiplicationDivisionModulo
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0() { return cPlusSignKeyword_1_0_0; }

		//{Expression_Plus.left=current}
		public Action getExpression_PlusLeftAction_1_0_1() { return cExpression_PlusLeftAction_1_0_1; }

		//right=Expression_MultiplicationDivisionModulo
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//Expression_MultiplicationDivisionModulo
		public RuleCall getRightExpression_MultiplicationDivisionModuloParserRuleCall_1_0_2_0() { return cRightExpression_MultiplicationDivisionModuloParserRuleCall_1_0_2_0; }

		//"-" {Expression_Minus.left=current} right=Expression_MultiplicationDivisionModulo
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1_0() { return cHyphenMinusKeyword_1_1_0; }

		//{Expression_Minus.left=current}
		public Action getExpression_MinusLeftAction_1_1_1() { return cExpression_MinusLeftAction_1_1_1; }

		//right=Expression_MultiplicationDivisionModulo
		public Assignment getRightAssignment_1_1_2() { return cRightAssignment_1_1_2; }

		//Expression_MultiplicationDivisionModulo
		public RuleCall getRightExpression_MultiplicationDivisionModuloParserRuleCall_1_1_2_0() { return cRightExpression_MultiplicationDivisionModuloParserRuleCall_1_1_2_0; }
	}

	public class Expression_MultiplicationDivisionModuloElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_MultiplicationDivisionModulo");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_UnaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Action cExpression_MultiplicationLeftAction_1_0_1 = (Action)cGroup_1_0.eContents().get(1);
		private final Assignment cRightAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRightExpression_UnaryParserRuleCall_1_0_2_0 = (RuleCall)cRightAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cSolidusKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Action cExpression_DivisionLeftAction_1_1_1 = (Action)cGroup_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRightExpression_UnaryParserRuleCall_1_1_2_0 = (RuleCall)cRightAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Keyword cPercentSignKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Action cExpression_ModuloLeftAction_1_2_1 = (Action)cGroup_1_2.eContents().get(1);
		private final Assignment cRightAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cRightExpression_UnaryParserRuleCall_1_2_2_0 = (RuleCall)cRightAssignment_1_2_2.eContents().get(0);
		
		//// multiplication/division, left associative, priority 5
		//Expression_MultiplicationDivisionModulo returns Expression:
		//	Expression_Unary ("*" {Expression_Multiplication.left=current} right=Expression_Unary | "/"
		//	{Expression_Division.left=current} right=Expression_Unary | "%" {Expression_Modulo.left=current}
		//	right=Expression_Unary)*;
		@Override public ParserRule getRule() { return rule; }

		//Expression_Unary ("*" {Expression_Multiplication.left=current} right=Expression_Unary | "/"
		//{Expression_Division.left=current} right=Expression_Unary | "%" {Expression_Modulo.left=current}
		//right=Expression_Unary)*
		public Group getGroup() { return cGroup; }

		//Expression_Unary
		public RuleCall getExpression_UnaryParserRuleCall_0() { return cExpression_UnaryParserRuleCall_0; }

		//("*" {Expression_Multiplication.left=current} right=Expression_Unary | "/" {Expression_Division.left=current}
		//right=Expression_Unary | "%" {Expression_Modulo.left=current} right=Expression_Unary)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"*" {Expression_Multiplication.left=current} right=Expression_Unary
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_0() { return cAsteriskKeyword_1_0_0; }

		//{Expression_Multiplication.left=current}
		public Action getExpression_MultiplicationLeftAction_1_0_1() { return cExpression_MultiplicationLeftAction_1_0_1; }

		//right=Expression_Unary
		public Assignment getRightAssignment_1_0_2() { return cRightAssignment_1_0_2; }

		//Expression_Unary
		public RuleCall getRightExpression_UnaryParserRuleCall_1_0_2_0() { return cRightExpression_UnaryParserRuleCall_1_0_2_0; }

		//"/" {Expression_Division.left=current} right=Expression_Unary
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"/"
		public Keyword getSolidusKeyword_1_1_0() { return cSolidusKeyword_1_1_0; }

		//{Expression_Division.left=current}
		public Action getExpression_DivisionLeftAction_1_1_1() { return cExpression_DivisionLeftAction_1_1_1; }

		//right=Expression_Unary
		public Assignment getRightAssignment_1_1_2() { return cRightAssignment_1_1_2; }

		//Expression_Unary
		public RuleCall getRightExpression_UnaryParserRuleCall_1_1_2_0() { return cRightExpression_UnaryParserRuleCall_1_1_2_0; }

		//"%" {Expression_Modulo.left=current} right=Expression_Unary
		public Group getGroup_1_2() { return cGroup_1_2; }

		//"%"
		public Keyword getPercentSignKeyword_1_2_0() { return cPercentSignKeyword_1_2_0; }

		//{Expression_Modulo.left=current}
		public Action getExpression_ModuloLeftAction_1_2_1() { return cExpression_ModuloLeftAction_1_2_1; }

		//right=Expression_Unary
		public Assignment getRightAssignment_1_2_2() { return cRightAssignment_1_2_2; }

		//Expression_Unary
		public RuleCall getRightExpression_UnaryParserRuleCall_1_2_2_0() { return cRightExpression_UnaryParserRuleCall_1_2_2_0; }
	}

	public class Expression_UnaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Unary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpression_ExponentiationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cExpression_NegateAction_1_1 = (Action)cGroup_1.eContents().get(1);
		private final Assignment cExpAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExpExpression_UnaryParserRuleCall_1_2_0 = (RuleCall)cExpAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cNumberSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Action cExpression_LengthAction_2_1 = (Action)cGroup_2.eContents().get(1);
		private final Assignment cExpAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cExpExpression_UnaryParserRuleCall_2_2_0 = (RuleCall)cExpAssignment_2_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cHyphenMinusKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Action cExpression_InvertAction_3_1 = (Action)cGroup_3.eContents().get(1);
		private final Assignment cExpAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final RuleCall cExpExpression_UnaryParserRuleCall_3_2_0 = (RuleCall)cExpAssignment_3_2.eContents().get(0);
		
		//// Unary operators: right associative, priority 6
		//Expression_Unary returns Expression:
		//	Expression_Exponentiation | "not" {Expression_Negate} exp=Expression_Unary | "#" {Expression_Length}
		//	exp=Expression_Unary | "-" {Expression_Invert} exp=Expression_Unary;
		@Override public ParserRule getRule() { return rule; }

		//Expression_Exponentiation | "not" {Expression_Negate} exp=Expression_Unary | "#" {Expression_Length}
		//exp=Expression_Unary | "-" {Expression_Invert} exp=Expression_Unary
		public Alternatives getAlternatives() { return cAlternatives; }

		//Expression_Exponentiation
		public RuleCall getExpression_ExponentiationParserRuleCall_0() { return cExpression_ExponentiationParserRuleCall_0; }

		//"not" {Expression_Negate} exp=Expression_Unary
		public Group getGroup_1() { return cGroup_1; }

		//"not"
		public Keyword getNotKeyword_1_0() { return cNotKeyword_1_0; }

		//{Expression_Negate}
		public Action getExpression_NegateAction_1_1() { return cExpression_NegateAction_1_1; }

		//exp=Expression_Unary
		public Assignment getExpAssignment_1_2() { return cExpAssignment_1_2; }

		//Expression_Unary
		public RuleCall getExpExpression_UnaryParserRuleCall_1_2_0() { return cExpExpression_UnaryParserRuleCall_1_2_0; }

		//"#" {Expression_Length} exp=Expression_Unary
		public Group getGroup_2() { return cGroup_2; }

		//"#"
		public Keyword getNumberSignKeyword_2_0() { return cNumberSignKeyword_2_0; }

		//{Expression_Length}
		public Action getExpression_LengthAction_2_1() { return cExpression_LengthAction_2_1; }

		//exp=Expression_Unary
		public Assignment getExpAssignment_2_2() { return cExpAssignment_2_2; }

		//Expression_Unary
		public RuleCall getExpExpression_UnaryParserRuleCall_2_2_0() { return cExpExpression_UnaryParserRuleCall_2_2_0; }

		//"-" {Expression_Invert} exp=Expression_Unary
		public Group getGroup_3() { return cGroup_3; }

		//"-"
		public Keyword getHyphenMinusKeyword_3_0() { return cHyphenMinusKeyword_3_0; }

		//{Expression_Invert}
		public Action getExpression_InvertAction_3_1() { return cExpression_InvertAction_3_1; }

		//exp=Expression_Unary
		public Assignment getExpAssignment_3_2() { return cExpAssignment_3_2; }

		//Expression_Unary
		public RuleCall getExpExpression_UnaryParserRuleCall_3_2_0() { return cExpExpression_UnaryParserRuleCall_3_2_0; }
	}

	public class Expression_ExponentiationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Exponentiation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_TerminalParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCircumflexAccentKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Action cExpression_ExponentiationLeftAction_1_1 = (Action)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightExpression_ExponentiationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// exponentiation: right associative, priority 7
		//Expression_Exponentiation returns Expression:
		//	Expression_Terminal ("^" {Expression_Exponentiation.left=current} right=Expression_Exponentiation)?;
		@Override public ParserRule getRule() { return rule; }

		//Expression_Terminal ("^" {Expression_Exponentiation.left=current} right=Expression_Exponentiation)?
		public Group getGroup() { return cGroup; }

		//Expression_Terminal
		public RuleCall getExpression_TerminalParserRuleCall_0() { return cExpression_TerminalParserRuleCall_0; }

		//("^" {Expression_Exponentiation.left=current} right=Expression_Exponentiation)?
		public Group getGroup_1() { return cGroup_1; }

		//"^"
		public Keyword getCircumflexAccentKeyword_1_0() { return cCircumflexAccentKeyword_1_0; }

		//{Expression_Exponentiation.left=current}
		public Action getExpression_ExponentiationLeftAction_1_1() { return cExpression_ExponentiationLeftAction_1_1; }

		//right=Expression_Exponentiation
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Expression_Exponentiation
		public RuleCall getRightExpression_ExponentiationParserRuleCall_1_2_0() { return cRightExpression_ExponentiationParserRuleCall_1_2_0; }
	}

	public class Expression_TerminalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Terminal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cExpression_NilParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpression_TrueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cExpression_FalseParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cExpression_NumberParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cExpression_VarArgsParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cExpression_StringParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cExpression_FunctionParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cExpression_TableConstructorParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cExpression_FunctioncallParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		
		//Expression_Terminal returns Expression:
		//	Expression_Nil | Expression_True | Expression_False | Expression_Number | Expression_VarArgs | Expression_String |
		//	Expression_Function | Expression_TableConstructor | Expression_Functioncall;
		@Override public ParserRule getRule() { return rule; }

		//Expression_Nil | Expression_True | Expression_False | Expression_Number | Expression_VarArgs | Expression_String |
		//Expression_Function | Expression_TableConstructor | Expression_Functioncall
		public Alternatives getAlternatives() { return cAlternatives; }

		//Expression_Nil
		public RuleCall getExpression_NilParserRuleCall_0() { return cExpression_NilParserRuleCall_0; }

		//Expression_True
		public RuleCall getExpression_TrueParserRuleCall_1() { return cExpression_TrueParserRuleCall_1; }

		//Expression_False
		public RuleCall getExpression_FalseParserRuleCall_2() { return cExpression_FalseParserRuleCall_2; }

		//Expression_Number
		public RuleCall getExpression_NumberParserRuleCall_3() { return cExpression_NumberParserRuleCall_3; }

		//Expression_VarArgs
		public RuleCall getExpression_VarArgsParserRuleCall_4() { return cExpression_VarArgsParserRuleCall_4; }

		//Expression_String
		public RuleCall getExpression_StringParserRuleCall_5() { return cExpression_StringParserRuleCall_5; }

		//Expression_Function
		public RuleCall getExpression_FunctionParserRuleCall_6() { return cExpression_FunctionParserRuleCall_6; }

		//Expression_TableConstructor
		public RuleCall getExpression_TableConstructorParserRuleCall_7() { return cExpression_TableConstructorParserRuleCall_7; }

		//Expression_Functioncall
		public RuleCall getExpression_FunctioncallParserRuleCall_8() { return cExpression_FunctioncallParserRuleCall_8; }
	}

	public class Expression_NilElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Nil");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNilKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cExpression_NilAction_1 = (Action)cGroup.eContents().get(1);
		
		//Expression_Nil:
		//	"nil" {Expression_Nil};
		@Override public ParserRule getRule() { return rule; }

		//"nil" {Expression_Nil}
		public Group getGroup() { return cGroup; }

		//"nil"
		public Keyword getNilKeyword_0() { return cNilKeyword_0; }

		//{Expression_Nil}
		public Action getExpression_NilAction_1() { return cExpression_NilAction_1; }
	}

	public class Expression_TrueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_True");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTrueKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cExpression_TrueAction_1 = (Action)cGroup.eContents().get(1);
		
		//Expression_True:
		//	"true" {Expression_True};
		@Override public ParserRule getRule() { return rule; }

		//"true" {Expression_True}
		public Group getGroup() { return cGroup; }

		//"true"
		public Keyword getTrueKeyword_0() { return cTrueKeyword_0; }

		//{Expression_True}
		public Action getExpression_TrueAction_1() { return cExpression_TrueAction_1; }
	}

	public class Expression_FalseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_False");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFalseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cExpression_FalseAction_1 = (Action)cGroup.eContents().get(1);
		
		//Expression_False:
		//	"false" {Expression_False};
		@Override public ParserRule getRule() { return rule; }

		//"false" {Expression_False}
		public Group getGroup() { return cGroup; }

		//"false"
		public Keyword getFalseKeyword_0() { return cFalseKeyword_0; }

		//{Expression_False}
		public Action getExpression_FalseAction_1() { return cExpression_FalseAction_1; }
	}

	public class Expression_NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Number");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueLUA_NUMBERTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Expression_Number:
		//	value=LUA_NUMBER;
		@Override public ParserRule getRule() { return rule; }

		//value=LUA_NUMBER
		public Assignment getValueAssignment() { return cValueAssignment; }

		//LUA_NUMBER
		public RuleCall getValueLUA_NUMBERTerminalRuleCall_0() { return cValueLUA_NUMBERTerminalRuleCall_0; }
	}

	public class Expression_VarArgsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_VarArgs");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopFullStopFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cExpression_VarArgsAction_1 = (Action)cGroup.eContents().get(1);
		
		//Expression_VarArgs:
		//	"..." {Expression_VarArgs};
		@Override public ParserRule getRule() { return rule; }

		//"..." {Expression_VarArgs}
		public Group getGroup() { return cGroup; }

		//"..."
		public Keyword getFullStopFullStopFullStopKeyword_0() { return cFullStopFullStopFullStopKeyword_0; }

		//{Expression_VarArgs}
		public Action getExpression_VarArgsAction_1() { return cExpression_VarArgsAction_1; }
	}

	public class Expression_StringElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_String");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueLUA_STRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//Expression_String:
		//	value=LUA_STRING;
		@Override public ParserRule getRule() { return rule; }

		//value=LUA_STRING
		public Assignment getValueAssignment() { return cValueAssignment; }

		//LUA_STRING
		public RuleCall getValueLUA_STRINGTerminalRuleCall_0() { return cValueLUA_STRINGTerminalRuleCall_0; }
	}

	public class Expression_FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFunctionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFunctionFunctionParserRuleCall_1_0 = (RuleCall)cFunctionAssignment_1.eContents().get(0);
		private final Keyword cEndKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Expression_Function:
		//	"function" function=Function "end";
		@Override public ParserRule getRule() { return rule; }

		//"function" function=Function "end"
		public Group getGroup() { return cGroup; }

		//"function"
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }

		//function=Function
		public Assignment getFunctionAssignment_1() { return cFunctionAssignment_1; }

		//Function
		public RuleCall getFunctionFunctionParserRuleCall_1_0() { return cFunctionFunctionParserRuleCall_1_0; }

		//"end"
		public Keyword getEndKeyword_2() { return cEndKeyword_2; }
	}

	public class Expression_TableConstructorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_TableConstructor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Action cExpression_TableConstructorAction_1 = (Action)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cFieldsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cFieldsFieldParserRuleCall_2_0_0 = (RuleCall)cFieldsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Alternatives cAlternatives_2_1_0 = (Alternatives)cGroup_2_1.eContents().get(0);
		private final Keyword cCommaKeyword_2_1_0_0 = (Keyword)cAlternatives_2_1_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1_0_1 = (Keyword)cAlternatives_2_1_0.eContents().get(1);
		private final Assignment cFieldsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cFieldsFieldParserRuleCall_2_1_1_0 = (RuleCall)cFieldsAssignment_2_1_1.eContents().get(0);
		private final Alternatives cAlternatives_2_2 = (Alternatives)cGroup_2.eContents().get(2);
		private final Keyword cCommaKeyword_2_2_0 = (Keyword)cAlternatives_2_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_2_1 = (Keyword)cAlternatives_2_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Expression_TableConstructor:
		//	"{" {Expression_TableConstructor} (fields+=Field (("," | ";") fields+=Field)* ("," | ";")?)? "}";
		@Override public ParserRule getRule() { return rule; }

		//"{" {Expression_TableConstructor} (fields+=Field (("," | ";") fields+=Field)* ("," | ";")?)? "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//{Expression_TableConstructor}
		public Action getExpression_TableConstructorAction_1() { return cExpression_TableConstructorAction_1; }

		//(fields+=Field (("," | ";") fields+=Field)* ("," | ";")?)?
		public Group getGroup_2() { return cGroup_2; }

		//fields+=Field
		public Assignment getFieldsAssignment_2_0() { return cFieldsAssignment_2_0; }

		//Field
		public RuleCall getFieldsFieldParserRuleCall_2_0_0() { return cFieldsFieldParserRuleCall_2_0_0; }

		//(("," | ";") fields+=Field)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//"," | ";"
		public Alternatives getAlternatives_2_1_0() { return cAlternatives_2_1_0; }

		//","
		public Keyword getCommaKeyword_2_1_0_0() { return cCommaKeyword_2_1_0_0; }

		//";"
		public Keyword getSemicolonKeyword_2_1_0_1() { return cSemicolonKeyword_2_1_0_1; }

		//fields+=Field
		public Assignment getFieldsAssignment_2_1_1() { return cFieldsAssignment_2_1_1; }

		//Field
		public RuleCall getFieldsFieldParserRuleCall_2_1_1_0() { return cFieldsFieldParserRuleCall_2_1_1_0; }

		//("," | ";")?
		public Alternatives getAlternatives_2_2() { return cAlternatives_2_2; }

		//","
		public Keyword getCommaKeyword_2_2_0() { return cCommaKeyword_2_2_0; }

		//";"
		public Keyword getSemicolonKeyword_2_2_1() { return cSemicolonKeyword_2_2_1; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}

	public class Expression_FunctioncallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_Functioncall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_AccessMemberOrArrayElementParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cColonKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Action cExpression_CallMemberFunctionObjectAction_1_0_1 = (Action)cGroup_1_0.eContents().get(1);
		private final Assignment cMemberFunctionNameAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cMemberFunctionNameLUA_NAMETerminalRuleCall_1_0_2_0 = (RuleCall)cMemberFunctionNameAssignment_1_0_2.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_0_3 = (Assignment)cGroup_1_0.eContents().get(3);
		private final RuleCall cArgumentsFunctioncall_ArgumentsParserRuleCall_1_0_3_0 = (RuleCall)cArgumentsAssignment_1_0_3.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Action cExpression_CallFunctionObjectAction_1_1_0 = (Action)cGroup_1_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cArgumentsFunctioncall_ArgumentsParserRuleCall_1_1_1_0 = (RuleCall)cArgumentsAssignment_1_1_1.eContents().get(0);
		
		//// Function calls, left associative, single call only, priority 9
		//Expression_Functioncall returns Expression:
		//	Expression_AccessMemberOrArrayElement (":" {Expression_CallMemberFunction.object=current} memberFunctionName=LUA_NAME
		//	arguments=Functioncall_Arguments // Member-Funktionsaufruf
		//	// Aufruf eines Funktionspointer:
		//	| {Expression_CallFunction.object=current} arguments=Functioncall_Arguments)?;
		@Override public ParserRule getRule() { return rule; }

		//Expression_AccessMemberOrArrayElement (":" {Expression_CallMemberFunction.object=current} memberFunctionName=LUA_NAME
		//arguments=Functioncall_Arguments // Member-Funktionsaufruf
		//// Aufruf eines Funktionspointer:
		//| {Expression_CallFunction.object=current} arguments=Functioncall_Arguments)?
		public Group getGroup() { return cGroup; }

		//Expression_AccessMemberOrArrayElement
		public RuleCall getExpression_AccessMemberOrArrayElementParserRuleCall_0() { return cExpression_AccessMemberOrArrayElementParserRuleCall_0; }

		//(":" {Expression_CallMemberFunction.object=current} memberFunctionName=LUA_NAME arguments=Functioncall_Arguments // Member-Funktionsaufruf
		//// Aufruf eines Funktionspointer:
		//| {Expression_CallFunction.object=current} arguments=Functioncall_Arguments)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//":" {Expression_CallMemberFunction.object=current} memberFunctionName=LUA_NAME arguments=Functioncall_Arguments
		public Group getGroup_1_0() { return cGroup_1_0; }

		//":"
		public Keyword getColonKeyword_1_0_0() { return cColonKeyword_1_0_0; }

		//{Expression_CallMemberFunction.object=current}
		public Action getExpression_CallMemberFunctionObjectAction_1_0_1() { return cExpression_CallMemberFunctionObjectAction_1_0_1; }

		//memberFunctionName=LUA_NAME
		public Assignment getMemberFunctionNameAssignment_1_0_2() { return cMemberFunctionNameAssignment_1_0_2; }

		//LUA_NAME
		public RuleCall getMemberFunctionNameLUA_NAMETerminalRuleCall_1_0_2_0() { return cMemberFunctionNameLUA_NAMETerminalRuleCall_1_0_2_0; }

		//arguments=Functioncall_Arguments
		public Assignment getArgumentsAssignment_1_0_3() { return cArgumentsAssignment_1_0_3; }

		//Functioncall_Arguments
		public RuleCall getArgumentsFunctioncall_ArgumentsParserRuleCall_1_0_3_0() { return cArgumentsFunctioncall_ArgumentsParserRuleCall_1_0_3_0; }

		//{Expression_CallFunction.object=current} arguments=Functioncall_Arguments
		public Group getGroup_1_1() { return cGroup_1_1; }

		//{Expression_CallFunction.object=current}
		public Action getExpression_CallFunctionObjectAction_1_1_0() { return cExpression_CallFunctionObjectAction_1_1_0; }

		//arguments=Functioncall_Arguments
		public Assignment getArgumentsAssignment_1_1_1() { return cArgumentsAssignment_1_1_1; }

		//Functioncall_Arguments
		public RuleCall getArgumentsFunctioncall_ArgumentsParserRuleCall_1_1_1_0() { return cArgumentsFunctioncall_ArgumentsParserRuleCall_1_1_1_0; }
	}

	public class Expression_AccessMemberOrArrayElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_AccessMemberOrArrayElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cExpression_VariableNameParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Action cExpression_AccessArrayArrayAction_1_0_1 = (Action)cGroup_1_0.eContents().get(1);
		private final Assignment cIndexAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cIndexExpressionParserRuleCall_1_0_2_0 = (RuleCall)cIndexAssignment_1_0_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_0_3 = (Keyword)cGroup_1_0.eContents().get(3);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cFullStopKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Action cExpression_AccessMemberObjectAction_1_1_1 = (Action)cGroup_1_1.eContents().get(1);
		private final Assignment cMemberNameAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cMemberNameLUA_NAMETerminalRuleCall_1_1_2_0 = (RuleCall)cMemberNameAssignment_1_1_2.eContents().get(0);
		
		//// Access a member or array element, left associative, chaining possible, priority 10
		//Expression_AccessMemberOrArrayElement returns Expression:
		//	Expression_VariableName ("[" {Expression_AccessArray.array=current} index=Expression "]" // An expression accessing an element in a variable array
		//	// Access a member variable using multiple parts separated by "."
		//	| "." {Expression_AccessMember.object=current} memberName=LUA_NAME)*;
		@Override public ParserRule getRule() { return rule; }

		//Expression_VariableName ("[" {Expression_AccessArray.array=current} index=Expression "]" // An expression accessing an element in a variable array
		//// Access a member variable using multiple parts separated by "."
		//| "." {Expression_AccessMember.object=current} memberName=LUA_NAME)*
		public Group getGroup() { return cGroup; }

		//Expression_VariableName
		public RuleCall getExpression_VariableNameParserRuleCall_0() { return cExpression_VariableNameParserRuleCall_0; }

		//("[" {Expression_AccessArray.array=current} index=Expression "]" // An expression accessing an element in a variable array
		//// Access a member variable using multiple parts separated by "."
		//| "." {Expression_AccessMember.object=current} memberName=LUA_NAME)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"[" {Expression_AccessArray.array=current} index=Expression "]"
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"["
		public Keyword getLeftSquareBracketKeyword_1_0_0() { return cLeftSquareBracketKeyword_1_0_0; }

		//{Expression_AccessArray.array=current}
		public Action getExpression_AccessArrayArrayAction_1_0_1() { return cExpression_AccessArrayArrayAction_1_0_1; }

		//index=Expression
		public Assignment getIndexAssignment_1_0_2() { return cIndexAssignment_1_0_2; }

		//Expression
		public RuleCall getIndexExpressionParserRuleCall_1_0_2_0() { return cIndexExpressionParserRuleCall_1_0_2_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_1_0_3() { return cRightSquareBracketKeyword_1_0_3; }

		//"." {Expression_AccessMember.object=current} memberName=LUA_NAME
		public Group getGroup_1_1() { return cGroup_1_1; }

		//"."
		public Keyword getFullStopKeyword_1_1_0() { return cFullStopKeyword_1_1_0; }

		//{Expression_AccessMember.object=current}
		public Action getExpression_AccessMemberObjectAction_1_1_1() { return cExpression_AccessMemberObjectAction_1_1_1; }

		//memberName=LUA_NAME
		public Assignment getMemberNameAssignment_1_1_2() { return cMemberNameAssignment_1_1_2; }

		//LUA_NAME
		public RuleCall getMemberNameLUA_NAMETerminalRuleCall_1_1_2_0() { return cMemberNameLUA_NAMETerminalRuleCall_1_1_2_0; }
	}

	public class Expression_VariableNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Expression_VariableName");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cExpression_VariableNameAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cVariableAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVariableLUA_NAMETerminalRuleCall_1_1_0 = (RuleCall)cVariableAssignment_1_1.eContents().get(0);
		
		//// access a variable, terminal expression, priority 11
		//// Delegate to top of expression rule chain for bracketed expressions
		//Expression_VariableName returns Expression:
		//	"(" Expression ")" | {Expression_VariableName} variable=LUA_NAME;
		@Override public ParserRule getRule() { return rule; }

		//"(" Expression ")" | {Expression_VariableName} variable=LUA_NAME
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Expression ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_0_1() { return cExpressionParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		//{Expression_VariableName} variable=LUA_NAME
		public Group getGroup_1() { return cGroup_1; }

		//{Expression_VariableName}
		public Action getExpression_VariableNameAction_1_0() { return cExpression_VariableNameAction_1_0; }

		//variable=LUA_NAME
		public Assignment getVariableAssignment_1_1() { return cVariableAssignment_1_1; }

		//LUA_NAME
		public RuleCall getVariableLUA_NAMETerminalRuleCall_1_1_0() { return cVariableLUA_NAMETerminalRuleCall_1_1_0; }
	}

	public class FunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Function");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cParametersAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cParametersLUA_NAMETerminalRuleCall_1_0_0 = (RuleCall)cParametersAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cParametersAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cParametersLUA_NAMETerminalRuleCall_1_1_1_0 = (RuleCall)cParametersAssignment_1_1_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final Assignment cVarArgsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Keyword cVarArgsFullStopFullStopFullStopKeyword_2_0 = (Keyword)cVarArgsAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cBodyAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cBodyBlockParserRuleCall_4_0 = (RuleCall)cBodyAssignment_4.eContents().get(0);
		
		//// ****************************************************
		//// FUNCTIONS
		//// ****************************************************
		//Function:
		//	"(" (parameters+=LUA_NAME ("," parameters+=LUA_NAME)* ","?)? varArgs?="..."? ")" body=Block;
		@Override public ParserRule getRule() { return rule; }

		//"(" (parameters+=LUA_NAME ("," parameters+=LUA_NAME)* ","?)? varArgs?="..."? ")" body=Block
		public Group getGroup() { return cGroup; }

		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }

		//(parameters+=LUA_NAME ("," parameters+=LUA_NAME)* ","?)?
		public Group getGroup_1() { return cGroup_1; }

		//parameters+=LUA_NAME
		public Assignment getParametersAssignment_1_0() { return cParametersAssignment_1_0; }

		//LUA_NAME
		public RuleCall getParametersLUA_NAMETerminalRuleCall_1_0_0() { return cParametersLUA_NAMETerminalRuleCall_1_0_0; }

		//("," parameters+=LUA_NAME)*
		public Group getGroup_1_1() { return cGroup_1_1; }

		//","
		public Keyword getCommaKeyword_1_1_0() { return cCommaKeyword_1_1_0; }

		//parameters+=LUA_NAME
		public Assignment getParametersAssignment_1_1_1() { return cParametersAssignment_1_1_1; }

		//LUA_NAME
		public RuleCall getParametersLUA_NAMETerminalRuleCall_1_1_1_0() { return cParametersLUA_NAMETerminalRuleCall_1_1_1_0; }

		//","?
		public Keyword getCommaKeyword_1_2() { return cCommaKeyword_1_2; }

		//varArgs?="..."?
		public Assignment getVarArgsAssignment_2() { return cVarArgsAssignment_2; }

		//"..."
		public Keyword getVarArgsFullStopFullStopFullStopKeyword_2_0() { return cVarArgsFullStopFullStopFullStopKeyword_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }

		//body=Block
		public Assignment getBodyAssignment_4() { return cBodyAssignment_4; }

		//Block
		public RuleCall getBodyBlockParserRuleCall_4_0() { return cBodyBlockParserRuleCall_4_0; }
	}

	public class Functioncall_ArgumentsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Functioncall_Arguments");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFunctioncall_ArgumentsAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Group cGroup_1_0_1 = (Group)cGroup_1_0.eContents().get(1);
		private final Assignment cArgumentsAssignment_1_0_1_0 = (Assignment)cGroup_1_0_1.eContents().get(0);
		private final RuleCall cArgumentsExpressionParserRuleCall_1_0_1_0_0 = (RuleCall)cArgumentsAssignment_1_0_1_0.eContents().get(0);
		private final Group cGroup_1_0_1_1 = (Group)cGroup_1_0_1.eContents().get(1);
		private final Keyword cCommaKeyword_1_0_1_1_0 = (Keyword)cGroup_1_0_1_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_0_1_1_1 = (Assignment)cGroup_1_0_1_1.eContents().get(1);
		private final RuleCall cArgumentsExpressionParserRuleCall_1_0_1_1_1_0 = (RuleCall)cArgumentsAssignment_1_0_1_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_0_2 = (Keyword)cGroup_1_0.eContents().get(2);
		private final Assignment cArgumentsAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cArgumentsExpression_TableConstructorParserRuleCall_1_1_0 = (RuleCall)cArgumentsAssignment_1_1.eContents().get(0);
		private final Assignment cArgumentsAssignment_1_2 = (Assignment)cAlternatives_1.eContents().get(2);
		private final RuleCall cArgumentsExpression_StringParserRuleCall_1_2_0 = (RuleCall)cArgumentsAssignment_1_2.eContents().get(0);
		
		//// Some syntactic sugar: strings and field can be passed as parameters without bracket
		//Functioncall_Arguments:
		//	{Functioncall_Arguments} ("(" (arguments+=Expression ("," arguments+=Expression)*)? ")" |
		//	arguments+=Expression_TableConstructor | arguments+=Expression_String);
		@Override public ParserRule getRule() { return rule; }

		//{Functioncall_Arguments} ("(" (arguments+=Expression ("," arguments+=Expression)*)? ")" |
		//arguments+=Expression_TableConstructor | arguments+=Expression_String)
		public Group getGroup() { return cGroup; }

		//{Functioncall_Arguments}
		public Action getFunctioncall_ArgumentsAction_0() { return cFunctioncall_ArgumentsAction_0; }

		//"(" (arguments+=Expression ("," arguments+=Expression)*)? ")" | arguments+=Expression_TableConstructor |
		//arguments+=Expression_String
		public Alternatives getAlternatives_1() { return cAlternatives_1; }

		//"(" (arguments+=Expression ("," arguments+=Expression)*)? ")"
		public Group getGroup_1_0() { return cGroup_1_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0_0() { return cLeftParenthesisKeyword_1_0_0; }

		//(arguments+=Expression ("," arguments+=Expression)*)?
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//arguments+=Expression
		public Assignment getArgumentsAssignment_1_0_1_0() { return cArgumentsAssignment_1_0_1_0; }

		//Expression
		public RuleCall getArgumentsExpressionParserRuleCall_1_0_1_0_0() { return cArgumentsExpressionParserRuleCall_1_0_1_0_0; }

		//("," arguments+=Expression)*
		public Group getGroup_1_0_1_1() { return cGroup_1_0_1_1; }

		//","
		public Keyword getCommaKeyword_1_0_1_1_0() { return cCommaKeyword_1_0_1_1_0; }

		//arguments+=Expression
		public Assignment getArgumentsAssignment_1_0_1_1_1() { return cArgumentsAssignment_1_0_1_1_1; }

		//Expression
		public RuleCall getArgumentsExpressionParserRuleCall_1_0_1_1_1_0() { return cArgumentsExpressionParserRuleCall_1_0_1_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_0_2() { return cRightParenthesisKeyword_1_0_2; }

		//arguments+=Expression_TableConstructor
		public Assignment getArgumentsAssignment_1_1() { return cArgumentsAssignment_1_1; }

		//Expression_TableConstructor
		public RuleCall getArgumentsExpression_TableConstructorParserRuleCall_1_1_0() { return cArgumentsExpression_TableConstructorParserRuleCall_1_1_0; }

		//arguments+=Expression_String
		public Assignment getArgumentsAssignment_1_2() { return cArgumentsAssignment_1_2; }

		//Expression_String
		public RuleCall getArgumentsExpression_StringParserRuleCall_1_2_0() { return cArgumentsExpression_StringParserRuleCall_1_2_0; }
	}

	public class FieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Field");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cField_AddEntryToTable_BracketsParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cField_AddEntryToTableParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cField_AppendEntryToTableParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// ****************************************************
		//// TABLES/FIELDS
		//// ****************************************************
		//Field:
		//	Field_AddEntryToTable_Brackets | Field_AddEntryToTable | Field_AppendEntryToTable;
		@Override public ParserRule getRule() { return rule; }

		//Field_AddEntryToTable_Brackets | Field_AddEntryToTable | Field_AppendEntryToTable
		public Alternatives getAlternatives() { return cAlternatives; }

		//Field_AddEntryToTable_Brackets
		public RuleCall getField_AddEntryToTable_BracketsParserRuleCall_0() { return cField_AddEntryToTable_BracketsParserRuleCall_0; }

		//Field_AddEntryToTable
		public RuleCall getField_AddEntryToTableParserRuleCall_1() { return cField_AddEntryToTableParserRuleCall_1; }

		//Field_AppendEntryToTable
		public RuleCall getField_AppendEntryToTableParserRuleCall_2() { return cField_AppendEntryToTableParserRuleCall_2; }
	}

	public class Field_AddEntryToTable_BracketsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Field_AddEntryToTable_Brackets");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIndexExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIndexExpressionExpressionParserRuleCall_1_0 = (RuleCall)cIndexExpressionAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValueExpressionParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		
		//// Each field of the form "[exp1] = exp2" adds to the new table an entry with key exp1 and value exp2
		//Field_AddEntryToTable_Brackets:
		//	"[" indexExpression=Expression "]" "=" value=Expression;
		@Override public ParserRule getRule() { return rule; }

		//"[" indexExpression=Expression "]" "=" value=Expression
		public Group getGroup() { return cGroup; }

		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }

		//indexExpression=Expression
		public Assignment getIndexExpressionAssignment_1() { return cIndexExpressionAssignment_1; }

		//Expression
		public RuleCall getIndexExpressionExpressionParserRuleCall_1_0() { return cIndexExpressionExpressionParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//value=Expression
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_4_0() { return cValueExpressionParserRuleCall_4_0; }
	}

	public class Field_AddEntryToTableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Field_AddEntryToTable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cKeyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cKeyLUA_NAMETerminalRuleCall_0_0 = (RuleCall)cKeyAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//// A field of the form "name = exp" is equivalent to ["name"] = exp
		//Field_AddEntryToTable:
		//	key=LUA_NAME "=" value=Expression;
		@Override public ParserRule getRule() { return rule; }

		//key=LUA_NAME "=" value=Expression
		public Group getGroup() { return cGroup; }

		//key=LUA_NAME
		public Assignment getKeyAssignment_0() { return cKeyAssignment_0; }

		//LUA_NAME
		public RuleCall getKeyLUA_NAMETerminalRuleCall_0_0() { return cKeyLUA_NAMETerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//value=Expression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_0() { return cValueExpressionParserRuleCall_2_0; }
	}

	public class Field_AppendEntryToTableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Field_AppendEntryToTable");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// fields of the form "exp" are equivalent to [i] = exp
		//Field_AppendEntryToTable:
		//	value=Expression;
		@Override public ParserRule getRule() { return rule; }

		//value=Expression
		public Assignment getValueAssignment() { return cValueAssignment; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_0() { return cValueExpressionParserRuleCall_0; }
	}
	
	
	private final ChunkElements pChunk;
	private final BlockElements pBlock;
	private final LastStatementElements pLastStatement;
	private final LastStatement_ReturnElements pLastStatement_Return;
	private final LastStatement_BreakElements pLastStatement_Break;
	private final StatementElements pStatement;
	private final Statement_BlockElements pStatement_Block;
	private final Statement_WhileElements pStatement_While;
	private final Statement_RepeatElements pStatement_Repeat;
	private final Statement_If_Then_ElseElements pStatement_If_Then_Else;
	private final Statement_If_Then_Else_ElseIfPartElements pStatement_If_Then_Else_ElseIfPart;
	private final Statement_For_NumericElements pStatement_For_Numeric;
	private final Statement_For_GenericElements pStatement_For_Generic;
	private final Statement_GlobalFunction_DeclarationElements pStatement_GlobalFunction_Declaration;
	private final Statement_LocalFunction_DeclarationElements pStatement_LocalFunction_Declaration;
	private final Statement_Local_Variable_DeclarationElements pStatement_Local_Variable_Declaration;
	private final Statement_FunctioncallOrAssignmentElements pStatement_FunctioncallOrAssignment;
	private final ExpressionElements pExpression;
	private final Expression_OrElements pExpression_Or;
	private final Expression_AndElements pExpression_And;
	private final Expression_CompareElements pExpression_Compare;
	private final Expression_ConcatenationElements pExpression_Concatenation;
	private final Expression_PlusMinusElements pExpression_PlusMinus;
	private final Expression_MultiplicationDivisionModuloElements pExpression_MultiplicationDivisionModulo;
	private final Expression_UnaryElements pExpression_Unary;
	private final Expression_ExponentiationElements pExpression_Exponentiation;
	private final Expression_TerminalElements pExpression_Terminal;
	private final Expression_NilElements pExpression_Nil;
	private final Expression_TrueElements pExpression_True;
	private final Expression_FalseElements pExpression_False;
	private final Expression_NumberElements pExpression_Number;
	private final Expression_VarArgsElements pExpression_VarArgs;
	private final Expression_StringElements pExpression_String;
	private final Expression_FunctionElements pExpression_Function;
	private final Expression_TableConstructorElements pExpression_TableConstructor;
	private final Expression_FunctioncallElements pExpression_Functioncall;
	private final Expression_AccessMemberOrArrayElementElements pExpression_AccessMemberOrArrayElement;
	private final Expression_VariableNameElements pExpression_VariableName;
	private final FunctionElements pFunction;
	private final Functioncall_ArgumentsElements pFunctioncall_Arguments;
	private final FieldElements pField;
	private final Field_AddEntryToTable_BracketsElements pField_AddEntryToTable_Brackets;
	private final Field_AddEntryToTableElements pField_AddEntryToTable;
	private final Field_AppendEntryToTableElements pField_AppendEntryToTable;
	private final TerminalRule tCOMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tLUA_NAME;
	private final TerminalRule tLUA_STRING;
	private final TerminalRule tLUA_NUMBER;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LuaGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pChunk = new ChunkElements();
		this.pBlock = new BlockElements();
		this.pLastStatement = new LastStatementElements();
		this.pLastStatement_Return = new LastStatement_ReturnElements();
		this.pLastStatement_Break = new LastStatement_BreakElements();
		this.pStatement = new StatementElements();
		this.pStatement_Block = new Statement_BlockElements();
		this.pStatement_While = new Statement_WhileElements();
		this.pStatement_Repeat = new Statement_RepeatElements();
		this.pStatement_If_Then_Else = new Statement_If_Then_ElseElements();
		this.pStatement_If_Then_Else_ElseIfPart = new Statement_If_Then_Else_ElseIfPartElements();
		this.pStatement_For_Numeric = new Statement_For_NumericElements();
		this.pStatement_For_Generic = new Statement_For_GenericElements();
		this.pStatement_GlobalFunction_Declaration = new Statement_GlobalFunction_DeclarationElements();
		this.pStatement_LocalFunction_Declaration = new Statement_LocalFunction_DeclarationElements();
		this.pStatement_Local_Variable_Declaration = new Statement_Local_Variable_DeclarationElements();
		this.pStatement_FunctioncallOrAssignment = new Statement_FunctioncallOrAssignmentElements();
		this.pExpression = new ExpressionElements();
		this.pExpression_Or = new Expression_OrElements();
		this.pExpression_And = new Expression_AndElements();
		this.pExpression_Compare = new Expression_CompareElements();
		this.pExpression_Concatenation = new Expression_ConcatenationElements();
		this.pExpression_PlusMinus = new Expression_PlusMinusElements();
		this.pExpression_MultiplicationDivisionModulo = new Expression_MultiplicationDivisionModuloElements();
		this.pExpression_Unary = new Expression_UnaryElements();
		this.pExpression_Exponentiation = new Expression_ExponentiationElements();
		this.pExpression_Terminal = new Expression_TerminalElements();
		this.pExpression_Nil = new Expression_NilElements();
		this.pExpression_True = new Expression_TrueElements();
		this.pExpression_False = new Expression_FalseElements();
		this.pExpression_Number = new Expression_NumberElements();
		this.pExpression_VarArgs = new Expression_VarArgsElements();
		this.pExpression_String = new Expression_StringElements();
		this.pExpression_Function = new Expression_FunctionElements();
		this.pExpression_TableConstructor = new Expression_TableConstructorElements();
		this.pExpression_Functioncall = new Expression_FunctioncallElements();
		this.pExpression_AccessMemberOrArrayElement = new Expression_AccessMemberOrArrayElementElements();
		this.pExpression_VariableName = new Expression_VariableNameElements();
		this.pFunction = new FunctionElements();
		this.pFunctioncall_Arguments = new Functioncall_ArgumentsElements();
		this.pField = new FieldElements();
		this.pField_AddEntryToTable_Brackets = new Field_AddEntryToTable_BracketsElements();
		this.pField_AddEntryToTable = new Field_AddEntryToTableElements();
		this.pField_AppendEntryToTable = new Field_AppendEntryToTableElements();
		this.tCOMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "WS");
		this.tLUA_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LUA_NAME");
		this.tLUA_STRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LUA_STRING");
		this.tLUA_NUMBER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LUA_NUMBER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.lua.Lua".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Chunk hidden(WS, COMMENT):
	//	Block;
	public ChunkElements getChunkAccess() {
		return pChunk;
	}
	
	public ParserRule getChunkRule() {
		return getChunkAccess().getRule();
	}

	//Block hidden(WS, COMMENT):
	//	{Block} (statements+=Statement ";"?)* (returnValue=LastStatement ";"?)?;
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}

	//// ****************************************************
	//// LAST STATEMENT
	//// ****************************************************
	//LastStatement:
	//	LastStatement_Return | LastStatement_Break;
	public LastStatementElements getLastStatementAccess() {
		return pLastStatement;
	}
	
	public ParserRule getLastStatementRule() {
		return getLastStatementAccess().getRule();
	}

	//// The return statement is used to return values from a function or a chunk
	//LastStatement_Return:
	//	"return" {LastStatement_ReturnWithValue} (returnValues+=Expression ("," returnValues+=Expression)*)?;
	public LastStatement_ReturnElements getLastStatement_ReturnAccess() {
		return pLastStatement_Return;
	}
	
	public ParserRule getLastStatement_ReturnRule() {
		return getLastStatement_ReturnAccess().getRule();
	}

	//// The break statement is used to terminate the execution of a while, repeat, or for loop, skipping to the next statement after the loop
	//LastStatement_Break:
	//	"break" {LastStatement_Break};
	public LastStatement_BreakElements getLastStatement_BreakAccess() {
		return pLastStatement_Break;
	}
	
	public ParserRule getLastStatement_BreakRule() {
		return getLastStatement_BreakAccess().getRule();
	}

	//// ****************************************************
	//// STATEMENT
	//// ****************************************************
	//Statement hidden(WS, COMMENT):
	//	Statement_Block | Statement_While | Statement_Repeat | Statement_If_Then_Else | Statement_For_Numeric |
	//	Statement_For_Generic | Statement_GlobalFunction_Declaration | Statement_LocalFunction_Declaration |
	//	Statement_Local_Variable_Declaration | Statement_FunctioncallOrAssignment;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//// A block can be explicitly delimited to produce a single statement. "do ... end"
	//Statement_Block:
	//	"do" block=Block "end";
	public Statement_BlockElements getStatement_BlockAccess() {
		return pStatement_Block;
	}
	
	public ParserRule getStatement_BlockRule() {
		return getStatement_BlockAccess().getRule();
	}

	//// Control structure. "while ... do ... end"
	//Statement_While:
	//	"while" expression=Expression "do" block=Block "end";
	public Statement_WhileElements getStatement_WhileAccess() {
		return pStatement_While;
	}
	
	public ParserRule getStatement_WhileRule() {
		return getStatement_WhileAccess().getRule();
	}

	//// Control structure. "repeat ... until ..."
	//Statement_Repeat:
	//	"repeat" block=Block "until" expression=Expression;
	public Statement_RepeatElements getStatement_RepeatAccess() {
		return pStatement_Repeat;
	}
	
	public ParserRule getStatement_RepeatRule() {
		return getStatement_RepeatAccess().getRule();
	}

	//// Control structure. "if ... then ... elseif ... elseif ... else ... end"
	//Statement_If_Then_Else:
	//	"if" ifExpression=Expression "then" ifBlock=Block elseIf+=Statement_If_Then_Else_ElseIfPart* ("else" elseBlock=Block)?
	//	"end";
	public Statement_If_Then_ElseElements getStatement_If_Then_ElseAccess() {
		return pStatement_If_Then_Else;
	}
	
	public ParserRule getStatement_If_Then_ElseRule() {
		return getStatement_If_Then_ElseAccess().getRule();
	}

	//Statement_If_Then_Else_ElseIfPart:
	//	"elseif" elseifExpression=Expression "then" elseifBlock=Block;
	public Statement_If_Then_Else_ElseIfPartElements getStatement_If_Then_Else_ElseIfPartAccess() {
		return pStatement_If_Then_Else_ElseIfPart;
	}
	
	public ParserRule getStatement_If_Then_Else_ElseIfPartRule() {
		return getStatement_If_Then_Else_ElseIfPartAccess().getRule();
	}

	//// The numeric for loop repeats a block of code while a control variable runs through an arithmetic progression "for ...=..., ... [,...] do ... end"
	//Statement_For_Numeric:
	//	"for" iteratorName=LUA_NAME "=" startExpr=Expression "," untilExpr=Expression ("," stepExpr=Expression)? "do"
	//	block=Block "end";
	public Statement_For_NumericElements getStatement_For_NumericAccess() {
		return pStatement_For_Numeric;
	}
	
	public ParserRule getStatement_For_NumericRule() {
		return getStatement_For_NumericAccess().getRule();
	}

	//// The generic for statement works over functions, called iterators. On each iteration, the iterator function is called to produce a new value, stopping when this new value is nil "for ... in ... do ... end"
	//Statement_For_Generic:
	//	"for" names+=LUA_NAME ("," names+=LUA_NAME)* "in" expressions+=Expression ("," expressions+=Expression)* "do"
	//	block=Block "end";
	public Statement_For_GenericElements getStatement_For_GenericAccess() {
		return pStatement_For_Generic;
	}
	
	public ParserRule getStatement_For_GenericRule() {
		return getStatement_For_GenericAccess().getRule();
	}

	//Statement_GlobalFunction_Declaration:
	//	"function" prefix+=LUA_NAME ("." prefix+=LUA_NAME)* (":" functionName=LUA_NAME)? function=Function "end";
	public Statement_GlobalFunction_DeclarationElements getStatement_GlobalFunction_DeclarationAccess() {
		return pStatement_GlobalFunction_Declaration;
	}
	
	public ParserRule getStatement_GlobalFunction_DeclarationRule() {
		return getStatement_GlobalFunction_DeclarationAccess().getRule();
	}

	//Statement_LocalFunction_Declaration:
	//	"local" "function" functionName=LUA_NAME function=Function "end";
	public Statement_LocalFunction_DeclarationElements getStatement_LocalFunction_DeclarationAccess() {
		return pStatement_LocalFunction_Declaration;
	}
	
	public ParserRule getStatement_LocalFunction_DeclarationRule() {
		return getStatement_LocalFunction_DeclarationAccess().getRule();
	}

	//// Local variables can be declared anywhere inside a block. The declaration can include an initial assignment "local ... [= ...]"
	//Statement_Local_Variable_Declaration:
	//	"local" variableNames+=LUA_NAME ("," variableNames+=LUA_NAME)* ("=" initialValue+=Expression (","
	//	initialValue+=Expression)*)?;
	public Statement_Local_Variable_DeclarationElements getStatement_Local_Variable_DeclarationAccess() {
		return pStatement_Local_Variable_Declaration;
	}
	
	public ParserRule getStatement_Local_Variable_DeclarationRule() {
		return getStatement_Local_Variable_DeclarationAccess().getRule();
	}

	//Statement_FunctioncallOrAssignment:
	//	Expression_AccessMemberOrArrayElement ({Statement_Assignment.variable+=current} (","
	//	variable+=Expression_AccessMemberOrArrayElement)* "=" values+=Expression ("," values+=Expression)* // Assignment
	//	// Call of a member function
	//	// Call of a function pointer
	//	| ":" {Statement_CallMemberFunction.object=current} memberFunctionName=LUA_NAME arguments=Functioncall_Arguments |
	//	{Statement_CallFunction.object=current} arguments=Functioncall_Arguments);
	public Statement_FunctioncallOrAssignmentElements getStatement_FunctioncallOrAssignmentAccess() {
		return pStatement_FunctioncallOrAssignment;
	}
	
	public ParserRule getStatement_FunctioncallOrAssignmentRule() {
		return getStatement_FunctioncallOrAssignmentAccess().getRule();
	}

	//// ****************************************************
	//// EXPRESSIONS
	//// ****************************************************
	//// Delegate to the priority chain of operators by calling the rule for the lowest priority operator
	//Expression hidden(WS, COMMENT):
	//	Expression_Or;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//// Or: left associative, priority 0
	//Expression_Or returns Expression:
	//	Expression_And ("or" {Expression_Or.left=current} right=Expression_And)*;
	public Expression_OrElements getExpression_OrAccess() {
		return pExpression_Or;
	}
	
	public ParserRule getExpression_OrRule() {
		return getExpression_OrAccess().getRule();
	}

	//// And: left associative, priority 1
	//Expression_And returns Expression:
	//	Expression_Compare ("and" {Expression_And.left=current} right=Expression_Compare)*;
	public Expression_AndElements getExpression_AndAccess() {
		return pExpression_And;
	}
	
	public ParserRule getExpression_AndRule() {
		return getExpression_AndAccess().getRule();
	}

	//// Comparisons: left associative, priority 2
	//Expression_Compare returns Expression:
	//	Expression_Concatenation (">" {Expression_Larger.left=current} right=Expression_Concatenation | ">="
	//	{Expression_Larger_Equal.left=current} right=Expression_Concatenation | "<" {Expression_Smaller.left=current}
	//	right=Expression_Concatenation | "<=" {Expression_Smaller_Equal.left=current} right=Expression_Concatenation | "=="
	//	{Expression_Equal.left=current} right=Expression_Concatenation | "~=" {Expression_Not_Equal.left=current}
	//	right=Expression_Concatenation)*;
	public Expression_CompareElements getExpression_CompareAccess() {
		return pExpression_Compare;
	}
	
	public ParserRule getExpression_CompareRule() {
		return getExpression_CompareAccess().getRule();
	}

	//// Concatenation: right associative, priority 3
	//Expression_Concatenation returns Expression:
	//	Expression_PlusMinus (".." {Expression_Concatenation.left=current} right=Expression_Concatenation)?;
	public Expression_ConcatenationElements getExpression_ConcatenationAccess() {
		return pExpression_Concatenation;
	}
	
	public ParserRule getExpression_ConcatenationRule() {
		return getExpression_ConcatenationAccess().getRule();
	}

	//// addition/subtraction: left associative, priority 4
	//Expression_PlusMinus returns Expression:
	//	Expression_MultiplicationDivisionModulo ("+" {Expression_Plus.left=current}
	//	right=Expression_MultiplicationDivisionModulo | "-" {Expression_Minus.left=current}
	//	right=Expression_MultiplicationDivisionModulo)*;
	public Expression_PlusMinusElements getExpression_PlusMinusAccess() {
		return pExpression_PlusMinus;
	}
	
	public ParserRule getExpression_PlusMinusRule() {
		return getExpression_PlusMinusAccess().getRule();
	}

	//// multiplication/division, left associative, priority 5
	//Expression_MultiplicationDivisionModulo returns Expression:
	//	Expression_Unary ("*" {Expression_Multiplication.left=current} right=Expression_Unary | "/"
	//	{Expression_Division.left=current} right=Expression_Unary | "%" {Expression_Modulo.left=current}
	//	right=Expression_Unary)*;
	public Expression_MultiplicationDivisionModuloElements getExpression_MultiplicationDivisionModuloAccess() {
		return pExpression_MultiplicationDivisionModulo;
	}
	
	public ParserRule getExpression_MultiplicationDivisionModuloRule() {
		return getExpression_MultiplicationDivisionModuloAccess().getRule();
	}

	//// Unary operators: right associative, priority 6
	//Expression_Unary returns Expression:
	//	Expression_Exponentiation | "not" {Expression_Negate} exp=Expression_Unary | "#" {Expression_Length}
	//	exp=Expression_Unary | "-" {Expression_Invert} exp=Expression_Unary;
	public Expression_UnaryElements getExpression_UnaryAccess() {
		return pExpression_Unary;
	}
	
	public ParserRule getExpression_UnaryRule() {
		return getExpression_UnaryAccess().getRule();
	}

	//// exponentiation: right associative, priority 7
	//Expression_Exponentiation returns Expression:
	//	Expression_Terminal ("^" {Expression_Exponentiation.left=current} right=Expression_Exponentiation)?;
	public Expression_ExponentiationElements getExpression_ExponentiationAccess() {
		return pExpression_Exponentiation;
	}
	
	public ParserRule getExpression_ExponentiationRule() {
		return getExpression_ExponentiationAccess().getRule();
	}

	//Expression_Terminal returns Expression:
	//	Expression_Nil | Expression_True | Expression_False | Expression_Number | Expression_VarArgs | Expression_String |
	//	Expression_Function | Expression_TableConstructor | Expression_Functioncall;
	public Expression_TerminalElements getExpression_TerminalAccess() {
		return pExpression_Terminal;
	}
	
	public ParserRule getExpression_TerminalRule() {
		return getExpression_TerminalAccess().getRule();
	}

	//Expression_Nil:
	//	"nil" {Expression_Nil};
	public Expression_NilElements getExpression_NilAccess() {
		return pExpression_Nil;
	}
	
	public ParserRule getExpression_NilRule() {
		return getExpression_NilAccess().getRule();
	}

	//Expression_True:
	//	"true" {Expression_True};
	public Expression_TrueElements getExpression_TrueAccess() {
		return pExpression_True;
	}
	
	public ParserRule getExpression_TrueRule() {
		return getExpression_TrueAccess().getRule();
	}

	//Expression_False:
	//	"false" {Expression_False};
	public Expression_FalseElements getExpression_FalseAccess() {
		return pExpression_False;
	}
	
	public ParserRule getExpression_FalseRule() {
		return getExpression_FalseAccess().getRule();
	}

	//Expression_Number:
	//	value=LUA_NUMBER;
	public Expression_NumberElements getExpression_NumberAccess() {
		return pExpression_Number;
	}
	
	public ParserRule getExpression_NumberRule() {
		return getExpression_NumberAccess().getRule();
	}

	//Expression_VarArgs:
	//	"..." {Expression_VarArgs};
	public Expression_VarArgsElements getExpression_VarArgsAccess() {
		return pExpression_VarArgs;
	}
	
	public ParserRule getExpression_VarArgsRule() {
		return getExpression_VarArgsAccess().getRule();
	}

	//Expression_String:
	//	value=LUA_STRING;
	public Expression_StringElements getExpression_StringAccess() {
		return pExpression_String;
	}
	
	public ParserRule getExpression_StringRule() {
		return getExpression_StringAccess().getRule();
	}

	//Expression_Function:
	//	"function" function=Function "end";
	public Expression_FunctionElements getExpression_FunctionAccess() {
		return pExpression_Function;
	}
	
	public ParserRule getExpression_FunctionRule() {
		return getExpression_FunctionAccess().getRule();
	}

	//Expression_TableConstructor:
	//	"{" {Expression_TableConstructor} (fields+=Field (("," | ";") fields+=Field)* ("," | ";")?)? "}";
	public Expression_TableConstructorElements getExpression_TableConstructorAccess() {
		return pExpression_TableConstructor;
	}
	
	public ParserRule getExpression_TableConstructorRule() {
		return getExpression_TableConstructorAccess().getRule();
	}

	//// Function calls, left associative, single call only, priority 9
	//Expression_Functioncall returns Expression:
	//	Expression_AccessMemberOrArrayElement (":" {Expression_CallMemberFunction.object=current} memberFunctionName=LUA_NAME
	//	arguments=Functioncall_Arguments // Member-Funktionsaufruf
	//	// Aufruf eines Funktionspointer:
	//	| {Expression_CallFunction.object=current} arguments=Functioncall_Arguments)?;
	public Expression_FunctioncallElements getExpression_FunctioncallAccess() {
		return pExpression_Functioncall;
	}
	
	public ParserRule getExpression_FunctioncallRule() {
		return getExpression_FunctioncallAccess().getRule();
	}

	//// Access a member or array element, left associative, chaining possible, priority 10
	//Expression_AccessMemberOrArrayElement returns Expression:
	//	Expression_VariableName ("[" {Expression_AccessArray.array=current} index=Expression "]" // An expression accessing an element in a variable array
	//	// Access a member variable using multiple parts separated by "."
	//	| "." {Expression_AccessMember.object=current} memberName=LUA_NAME)*;
	public Expression_AccessMemberOrArrayElementElements getExpression_AccessMemberOrArrayElementAccess() {
		return pExpression_AccessMemberOrArrayElement;
	}
	
	public ParserRule getExpression_AccessMemberOrArrayElementRule() {
		return getExpression_AccessMemberOrArrayElementAccess().getRule();
	}

	//// access a variable, terminal expression, priority 11
	//// Delegate to top of expression rule chain for bracketed expressions
	//Expression_VariableName returns Expression:
	//	"(" Expression ")" | {Expression_VariableName} variable=LUA_NAME;
	public Expression_VariableNameElements getExpression_VariableNameAccess() {
		return pExpression_VariableName;
	}
	
	public ParserRule getExpression_VariableNameRule() {
		return getExpression_VariableNameAccess().getRule();
	}

	//// ****************************************************
	//// FUNCTIONS
	//// ****************************************************
	//Function:
	//	"(" (parameters+=LUA_NAME ("," parameters+=LUA_NAME)* ","?)? varArgs?="..."? ")" body=Block;
	public FunctionElements getFunctionAccess() {
		return pFunction;
	}
	
	public ParserRule getFunctionRule() {
		return getFunctionAccess().getRule();
	}

	//// Some syntactic sugar: strings and field can be passed as parameters without bracket
	//Functioncall_Arguments:
	//	{Functioncall_Arguments} ("(" (arguments+=Expression ("," arguments+=Expression)*)? ")" |
	//	arguments+=Expression_TableConstructor | arguments+=Expression_String);
	public Functioncall_ArgumentsElements getFunctioncall_ArgumentsAccess() {
		return pFunctioncall_Arguments;
	}
	
	public ParserRule getFunctioncall_ArgumentsRule() {
		return getFunctioncall_ArgumentsAccess().getRule();
	}

	//// ****************************************************
	//// TABLES/FIELDS
	//// ****************************************************
	//Field:
	//	Field_AddEntryToTable_Brackets | Field_AddEntryToTable | Field_AppendEntryToTable;
	public FieldElements getFieldAccess() {
		return pField;
	}
	
	public ParserRule getFieldRule() {
		return getFieldAccess().getRule();
	}

	//// Each field of the form "[exp1] = exp2" adds to the new table an entry with key exp1 and value exp2
	//Field_AddEntryToTable_Brackets:
	//	"[" indexExpression=Expression "]" "=" value=Expression;
	public Field_AddEntryToTable_BracketsElements getField_AddEntryToTable_BracketsAccess() {
		return pField_AddEntryToTable_Brackets;
	}
	
	public ParserRule getField_AddEntryToTable_BracketsRule() {
		return getField_AddEntryToTable_BracketsAccess().getRule();
	}

	//// A field of the form "name = exp" is equivalent to ["name"] = exp
	//Field_AddEntryToTable:
	//	key=LUA_NAME "=" value=Expression;
	public Field_AddEntryToTableElements getField_AddEntryToTableAccess() {
		return pField_AddEntryToTable;
	}
	
	public ParserRule getField_AddEntryToTableRule() {
		return getField_AddEntryToTableAccess().getRule();
	}

	//// fields of the form "exp" are equivalent to [i] = exp
	//Field_AppendEntryToTable:
	//	value=Expression;
	public Field_AppendEntryToTableElements getField_AppendEntryToTableAccess() {
		return pField_AppendEntryToTable;
	}
	
	public ParserRule getField_AppendEntryToTableRule() {
		return getField_AppendEntryToTableAccess().getRule();
	}

	//// ****************************************************
	//// TERMINALS
	//// ****************************************************
	//terminal COMMENT:
	//	"--" ("[["->"]]" | !"[" !"\n"* "\n"?);
	public TerminalRule getCOMMENTRule() {
		return tCOMMENT;
	} 

	//// Consume all white space, tabs and new line characters
	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return tWS;
	} 

	//// Identifiers can be any string of letters, digits, and underscores, but mustn't begin with a digit.
	//terminal LUA_NAME:
	//	("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getLUA_NAMERule() {
		return tLUA_NAME;
	} 

	//terminal LUA_STRING:
	//	"\'" ("\\" ("a" | "b" | "f" | "n" | "r" | "t" | "v" | "\"" | "\'" | "\\" | "0".."9" ("0".."9" "0".."9")) | !("\\" |
	//	"\'"))* "\'" | "\"" ("\\" ("a" | "b" | "f" | "n" | "r" | "t" | "v" | "\"" | "\'" | "\\" | "0".."9" ("0".."9"
	//	"0".."9")) | !("\\" | "\""))* "\"" | "[["->"]]";
	public TerminalRule getLUA_STRINGRule() {
		return tLUA_STRING;
	} 

	//terminal LUA_NUMBER returns ecore::EDouble:
	//	"0".."9"+ ("." "0".."9"+ (("E" | "e") "-"? "0".."9"+)?)? | "0x" ("0".."9" | "a".."f")+;
	public TerminalRule getLUA_NUMBERRule() {
		return tLUA_NUMBER;
	} 

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}

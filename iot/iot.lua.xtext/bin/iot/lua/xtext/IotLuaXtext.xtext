// automatically generated by Xtext
grammar iot.lua.xtext.IotLuaXtext with org.eclipse.xtext.common.Terminals

import "platform:/resource/iot.model/model/iot.ecore" as iot
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.xtext.lua/model/generated/Lua.ecore" as lua
import "platform:/resource/iot.lua.model/model/iot_lua.ecore" as iot_lua
import "platform:/resource/org.xtext.activitydiagram.model/model/activitydiagram.ecore" as activitydiagram
import "platform:/resource/org.csu.idl.idlmm/model/IDLMM.ecore" as idlmm

System returns iot::System:
	'system' name=ID '{'
		(components+=HWComponent (components+=HWComponent)*)?
		(boards+=Board (boards+=Board)*)?
		(sketch=Sketch)?
	'}';

HWComponent returns iot::HWComp:
	Sensor | Actuator;

Sensor returns iot::Sensor:
	'sensor' name = ID ('{'
		('provides' services += IotOperationDef)*
	'}')?
;

Actuator returns iot::Actuator:
	'actuator' name = ID ('{'
		('provides' services += IotOperationDef)*
	'}')?
;

Board returns iot::Board:
	{iot::Board}
	'board' name=ID '[' type = BoardType ']'
	('{'
		('provides' components+=[iot::HWComp|ID])*
	'}')?;

enum BoardType returns iot::BoardType:
	RaspberryPi = 'RaspberryPi' | Arduino = 'Arduino' | BeagleBoard = 'BeagleBoard'
;

Sketch returns iot::Sketch:
	{iot::Sketch}
	'sketch'
	'{'
		activity=IotActivity
	'}';

EBoolean returns ecore::EBoolean:
	'true' | 'false';

IotOperationDef returns iot::IotOperationDef:
	{iot_lua::IotOperationDefBindOperationDef}
	delegate=OperationDef
;
	
OperationDef returns idlmm::OperationDef:
	'operation'
	identifier=ID
	'(' ( parameters += ParameterDef (',' parameters += ParameterDef)* )? ')'
	'{'
		stmt=IdlStmt
	'}';


IdlStmt returns idlmm::IdlStmt:
	{iot_lua::IdlStmtBindBlock}
	delegate=Block
;

ParameterDef returns idlmm::ParameterDef: 
	direction=param_attribute //(containedType=PrimitiveDef)
	identifier=ID
;

enum param_attribute returns idlmm::ParameterMode:
	PARAM_IN='in'
	|	PARAM_OUT='out'
	|	PARAM_INOUT='inout'
;

PrimitiveDef returns idlmm::PrimitiveDef
	:	integer_type
	|	floating_pt_type
	|	charstr_type
	|	other_type
	;

//---------------------------
// BASE TYPES
//---------------------------


floating_pt_type returns idlmm::PrimitiveDef
	:	kind = float_type
	|	kind = double_type
	|	kind = longdouble_type
	;

enum float_type returns idlmm::PrimitiveKind
	:	PK_FLOAT = 'float'
	;

enum double_type returns idlmm::PrimitiveKind
	:	PK_DOUBLE = 'double'
	;

longdouble_type returns idlmm::PrimitiveKind
	:	'long' 'double'
	;


integer_type returns idlmm::PrimitiveDef
	:	kind = short_type
	|	kind = long_type
	|	kind = longlong_type
	|	kind = ushort_type
	|	kind = ulong_type
	|	kind = ulonglong_type
	;

enum short_type returns idlmm::PrimitiveKind
	:	PK_SHORT = 'short'
	;

enum long_type returns idlmm::PrimitiveKind
	:	PK_LONG = 'long'
	;

longlong_type returns idlmm::PrimitiveKind
	:	'long' 'long'
	;

ushort_type returns idlmm::PrimitiveKind
	:	'unsigned' 'short'
	;

ulong_type returns idlmm::PrimitiveKind
	:	'unsigned' 'long'
	;

ulonglong_type returns idlmm::PrimitiveKind
	:	'unsigned' 'long' 'long'
	;



charstr_type returns idlmm::PrimitiveDef
	:	kind = char_type
	|	kind = wide_char_type
	|	kind = string_type
	|	kind = wide_string_type
	;

enum char_type returns idlmm::PrimitiveKind
	:	PK_CHAR = 'char'
	;

enum wide_char_type returns idlmm::PrimitiveKind
	:	PK_WCHAR = 'wchar'
	;

enum string_type returns idlmm::PrimitiveKind
	:	PK_STRING = 'string'
	;

enum wide_string_type returns idlmm::PrimitiveKind
	:	PK_WSTRING = 'wstring'
	;


other_type returns idlmm::PrimitiveDef
	:	kind = boolean_type
	|	kind = octet_type
	|	kind = any_type
	;
	
enum boolean_type returns idlmm::PrimitiveKind
	:	PK_BOOLEAN = 'boolean'
	;

enum octet_type returns idlmm::PrimitiveKind
	:	PK_OCTET = 'octet'
	;

enum any_type returns idlmm::PrimitiveKind
	:	PK_ANY = 'any'
	;


enum object_type returns idlmm::PrimitiveKind
	:	PK_OBJREF = 'Object'
	;

enum void_type returns idlmm::PrimitiveKind
	:	PK_VOID = 'void'
	;

Chunk returns lua::Block:
	Block
;
 
Block returns lua::Block:
    {lua::Block}
    (statements+=Statement (';')? )*
    ( returnValue=LastStatement (';')? )?;
 
// ****************************************************
// LAST STATEMENT
// ****************************************************
LastStatement returns lua::LastStatement: 
    LastStatement_Return | LastStatement_Break;
 
// The return statement is used to return values from a function or a chunk
LastStatement_Return returns lua::LastStatement_Return: 
    'return' {lua::LastStatement_ReturnWithValue} (returnValues+=Expression (',' returnValues+=Expression)*)?;
 
// The break statement is used to terminate the execution of a while, repeat, or for loop, skipping to the next statement after the loop
LastStatement_Break returns lua::LastStatement_Break: 
    'break' {lua::LastStatement_Break};
 
// ****************************************************
// STATEMENT
// ****************************************************
Statement returns lua::Statement:
	Statement_Block |
	Statement_While |
	Statement_Repeat |
	Statement_If_Then_Else |
	Statement_For_Numeric |
	Statement_For_Generic |
	Statement_GlobalFunction_Declaration |
	Statement_LocalFunction_Declaration |
	Statement_Local_Variable_Declaration |
	Statement_FunctioncallOrAssignment;
 
// A block can be explicitly delimited to produce a single statement. "do ... end"
Statement_Block returns lua::Statement_Block: 
    'do' block=Block 'end';
 
// Control structure. "while ... do ... end"
Statement_While returns lua::Statement_While: 
    'while' expression=Expression 'do' block=Block 'end';
 
// Control structure. "repeat ... until ..."
Statement_Repeat returns lua::Statement_Repeat: 
    'repeat' block=Block 'until' expression=Expression;
 
// Control structure. "if ... then ... elseif ... elseif ... else ... end"
Statement_If_Then_Else returns lua::Statement_If_Then_Else: 
    'if' ifExpression=Expression 'then' ifBlock=Block (elseIf+=Statement_If_Then_Else_ElseIfPart)* ('else' elseBlock=Block)? 'end';
Statement_If_Then_Else_ElseIfPart returns lua::Statement_If_Then_Else_ElseIfPart: 
    'elseif' elseifExpression=Expression 'then' elseifBlock=Block;
 
// The numeric for loop repeats a block of code while a control variable runs through an arithmetic progression "for ...=..., ... [,...] do ... end"
Statement_For_Numeric returns lua::Statement_For_Numeric: 
    'for' iteratorName=ID '=' startExpr=Expression "," untilExpr=Expression ("," stepExpr=Expression)? 'do' block=Block 'end';
 
// The generic for statement works over functions, called iterators. On each iteration, the iterator function is called to produce a new value, stopping when this new value is nil "for ... in ... do ... end"
Statement_For_Generic returns lua::Statement_For_Generic: 
    'for' names+=ID (',' names+=ID)* 'in' expressions+=Expression (',' expressions+=Expression)* 'do' block=Block 'end';
 
Statement_GlobalFunction_Declaration returns lua::Statement_GlobalFunction_Declaration: 
    'function' prefix+=ID ('.' prefix+=ID)* (':' functionName=ID)? function=Function 'end';
 
Statement_LocalFunction_Declaration returns lua::Statement_LocalFunction_Declaration: 
    'local' 'function' functionName=ID function=Function 'end';
 
// Local variables can be declared anywhere inside a block. The declaration can include an initial assignment "local ... [= ...]"
Statement_Local_Variable_Declaration returns lua::Statement_Local_Variable_Declaration: 
    'local' variableNames+=ID (',' variableNames+=ID)* ('=' initialValue+=Expression (',' initialValue+=Expression)*)?;
 
Statement_FunctioncallOrAssignment returns lua::Statement_FunctioncallOrAssignment:
	Expression_AccessMemberOrArrayElement (
	// Assignment
	({lua::Statement_Assignment.variable+=current} (=> ',' variable+=Expression_AccessMemberOrArrayElement)* '='
	values+=Expression (',' values+=Expression)*) |

	// Call of a member function
	(':' {lua::Statement_CallMemberFunction.object=current} memberFunctionName=ID arguments=Functioncall_Arguments) |

	// Call of a function pointer
	({lua::Statement_CallFunction.object=current} arguments=Functioncall_Arguments));
 
// ****************************************************
// EXPRESSIONS
// ****************************************************
// Delegate to the priority chain of operators by calling the rule for the lowest priority operator
Expression returns lua::Expression: 
    Expression_Or;
 
// Or: left associative, priority 0
Expression_Or returns lua::Expression: 
    Expression_And ('or' {lua::Expression_Or.left=current} right=Expression_And)*;
 
// And: left associative, priority 1
Expression_And returns lua::Expression: 
    Expression_Compare ('and' {lua::Expression_And.left=current} right=Expression_Compare)*;
 
// Comparisons: left associative, priority 2
Expression_Compare returns lua::Expression: 
    Expression_Concatenation (
        ('>'  {lua::Expression_Larger.left=current} right=Expression_Concatenation) |
        ('>=' {lua::Expression_Larger_Equal.left=current} right=Expression_Concatenation) |
        ('<'  {lua::Expression_Smaller.left=current} right=Expression_Concatenation) |
        ('<=' {lua::Expression_Smaller_Equal.left=current} right=Expression_Concatenation) |
        ('==' {lua::Expression_Equal.left=current} right=Expression_Concatenation) |
        ('~=' {lua::Expression_Not_Equal.left=current} right=Expression_Concatenation)
    )*;
 
// Concatenation: right associative, priority 3
Expression_Concatenation returns lua::Expression: 
    Expression_PlusMinus ('..' {lua::Expression_Concatenation.left=current} right=Expression_Concatenation)?;
 
// addition/subtraction: left associative, priority 4
Expression_PlusMinus returns lua::Expression: 
    Expression_MultiplicationDivisionModulo (
        ('+'  {lua::Expression_Plus.left=current} right=Expression_MultiplicationDivisionModulo) |
        ('-'  {lua::Expression_Minus.left=current} right=Expression_MultiplicationDivisionModulo)
    )*;
 
// multiplication/division, left associative, priority 5
Expression_MultiplicationDivisionModulo returns lua::Expression:
    Expression_Unary (
        ('*'  {lua::Expression_Multiplication.left=current} right=Expression_Unary) |
        ('/'  {lua::Expression_Division.left=current} right=Expression_Unary) |
        ('%'  {lua::Expression_Modulo.left=current} right=Expression_Unary)
    )*;
 
// Unary operators: right associative, priority 6
Expression_Unary returns lua::Expression: 
    Expression_Exponentiation |
    ('not' {lua::Expression_Negate} exp=Expression_Unary) |
    ('#'   {lua::Expression_Length} exp=Expression_Unary) |
    ('-'   {lua::Expression_Invert} exp=Expression_Unary);
 
// exponentiation: right associative, priority 7
Expression_Exponentiation returns lua::Expression: 
    Expression_Terminal
    ( '^' {lua::Expression_Exponentiation.left=current} right=Expression_Exponentiation )?;
 
Expression_Terminal returns lua::Expression:
    Expression_Nil |
    Expression_True |
    Expression_False |
    Expression_Number |
    Expression_VarArgs |
    Expression_String |
    Expression_Function |
    Expression_TableConstructor |
    Expression_Functioncall;
 
Expression_Nil returns lua::Expression_Nil: 
    'nil' {lua::Expression_Nil};
Expression_True returns lua::Expression_True: 
    'true' {lua::Expression_True};
Expression_False returns lua::Expression_False: 
    'false' {lua::Expression_False};
Expression_Number returns lua::Expression_Number: 
    value=Double;
Expression_VarArgs returns lua::Expression_VarArgs: 
    '...' {lua::Expression_VarArgs};
Expression_String returns lua::Expression_String: 
    value=STRING;
Expression_Function returns lua::Expression_Function: 
    'function' function=Function 'end';
Expression_TableConstructor returns lua::Expression_TableConstructor: 
    '{' {lua::Expression_TableConstructor} (fields+=Field ((','|';') fields+=Field)* (','|';')? )? '}';
 
// Function calls, left associative, single call only, priority 9
Expression_Functioncall returns lua::Expression: 
    Expression_AccessMemberOrArrayElement (
        // Member-Funktionsaufruf
        (=> ':' {lua::Expression_CallMemberFunction.object=current} memberFunctionName=ID arguments=Functioncall_Arguments) |
 
        // Aufruf eines Funktionspointer:
        ({lua::Expression_CallFunction.object=current} arguments=Functioncall_Arguments)
    )?;
 
// Access a member or array element, left associative, chaining possible, priority 10
Expression_AccessMemberOrArrayElement returns lua::Expression: 
    Expression_VariableName (
        // An expression accessing an element in a variable array
        ('[' {lua::Expression_AccessArray.array=current} index=Expression ']') |
 
        // Access a member variable using multiple parts separated by "."
        ('.' {lua::Expression_AccessMember.object=current} memberName=ID)
    )*;
 
// access a variable, terminal expression, priority 11
// Delegate to top of expression rule chain for bracketed expressions
Expression_VariableName returns lua::Expression: 
    ('(' Expression ')') |
    ({lua::Expression_VariableName} variable=ID);
 
 
// ****************************************************
// FUNCTIONS
// ****************************************************
Function returns lua::Function: 
    '(' (parameters+=ID (',' parameters+=ID)* ','?)? (varArgs?='...')? ')' body=Block;
 
// Some syntactic sugar: strings and field can be passed as parameters without bracket
Functioncall_Arguments returns lua::Functioncall_Arguments: 
    {lua::Functioncall_Arguments}
    (
        ('(' (arguments+=Expression (',' arguments+=Expression)*)? ')' ) |
        (arguments+=Expression_TableConstructor) |
        (arguments+=Expression_String)
    );
 
// ****************************************************
// TABLES/FIELDS
// ****************************************************
Field returns lua::Field: 
    Field_AddEntryToTable_Brackets |
    Field_AddEntryToTable |
    Field_AppendEntryToTable;
 
// Each field of the form "[exp1] = exp2" adds to the new table an entry with key exp1 and value exp2
Field_AddEntryToTable_Brackets returns lua::Field_AddEntryToTable_Brackets: 
    '[' indexExpression=Expression ']' '=' value=Expression;
 
// A field of the form "name = exp" is equivalent to ["name"] = exp
Field_AddEntryToTable returns lua::Field_AddEntryToTable: 
    key=ID '=' value=Expression;
 
// fields of the form "exp" are equivalent to [i] = exp
Field_AppendEntryToTable returns lua::Field_AppendEntryToTable: 
    value=Expression;
 
// ****************************************************
// TERMINALS
// ****************************************************
// Identifiers can be any string of letters, digits, and underscores, but mustn't begin with a digit.

IotActivity returns iot::IotActivity:
	{iot_lua::IotActivityBindActivity}
	delegate=Activity
;

Activity returns activitydiagram::Activity:
	{activitydiagram::Activity}
	'activity'
	name=ID ('(' inputs+=Variable ( "," inputs+=Variable)* ')' )?
	'{'
		(locals+=Variable ( "," locals+=Variable)* )?
		('nodes' '{' nodes+=ActivityNode ( "," nodes+=ActivityNode)* '}' )?
		('edges' '{' edges+=ActivityEdge ( "," edges+=ActivityEdge)* '}' )?

	'}';

ActivityNode returns activitydiagram::ActivityNode:
	OpaqueAction | InitialNode | ActivityFinalNode | ForkNode | JoinNode | MergeNode | DecisionNode;

ActivityEdge returns activitydiagram::ActivityEdge:
	ControlFlow;

Variable returns activitydiagram::Variable:
	IntegerVariable | BooleanVariable;

Value returns activitydiagram::Value:
	BooleanValue | IntegerValue;

OpaqueAction returns activitydiagram::OpaqueAction:
	{activitydiagram::OpaqueAction}
	'action'
	name=ID
		('comp' '{' expressions+=ExpBindStatement ( "," expressions+=ExpBindStatement)* '}' )?
		('in' '(' incoming+=[activitydiagram::ActivityEdge] ( "," incoming+=[activitydiagram::ActivityEdge])* ')' )?
		('out' '(' outgoing+=[activitydiagram::ActivityEdge] ( "," outgoing+=[activitydiagram::ActivityEdge])* ')' )?
		('service' expressions += ExpBindOpDef)?
		;
		
		
ExpBindOpDef returns activitydiagram::Exp:
	{iot_lua::ExpressionBindOperationDef} delegate=[idlmm::OperationDef]
;

ExpBindStatement returns activitydiagram::Exp:
	{iot_lua::ExpressionBindStatement} delegate=Statement	
;

InitialNode returns activitydiagram::InitialNode:
	{activitydiagram::InitialNode}
	'initial'
	name=ID
		('out' '(' outgoing+=[activitydiagram::ActivityEdge] ( "," outgoing+=[activitydiagram::ActivityEdge])* ')' )
	;

ActivityFinalNode returns activitydiagram::ActivityFinalNode:
	{activitydiagram::ActivityFinalNode}
	'final'
	name=ID
		('in' '(' incoming+=[activitydiagram::ActivityEdge] ( "," incoming+=[activitydiagram::ActivityEdge])* ')' )
	;

ForkNode returns activitydiagram::ForkNode:
	{activitydiagram::ForkNode}
	'fork'
	name=ID
		('in' '(' incoming+=[activitydiagram::ActivityEdge] ')' )
		('out' '(' outgoing+=[activitydiagram::ActivityEdge] ( "," outgoing+=[activitydiagram::ActivityEdge])* ')' )?
	;

JoinNode returns activitydiagram::JoinNode:
	{activitydiagram::JoinNode}
	'join'
	name=ID
		('in' '(' incoming+=[activitydiagram::ActivityEdge] ( "," incoming+=[activitydiagram::ActivityEdge])* ')' )?
		('out' '(' outgoing+=[activitydiagram::ActivityEdge] ')' )
	;

MergeNode returns activitydiagram::MergeNode:
	{activitydiagram::MergeNode}
	'merge'
	name=ID
		('in' '(' incoming+=[activitydiagram::ActivityEdge] ( "," incoming+=[activitydiagram::ActivityEdge])* ')' )?
		('out' '(' outgoing+=[activitydiagram::ActivityEdge] ')' )
	;

DecisionNode returns activitydiagram::DecisionNode:
	{activitydiagram::DecisionNode}
	'decision'
	name=ID
		('in' '(' incoming+=[activitydiagram::ActivityEdge] ')' )
		('out' '(' outgoing+=[activitydiagram::ActivityEdge] ( "," outgoing+=[activitydiagram::ActivityEdge])* ')' )?
	;

IntegerVariable returns activitydiagram::IntegerVariable:
	{iot_lua::IntegerVariableBindStatement_Assignment}
	'int' delegate=Statement_FunctioncallOrAssignment;
	
BooleanVariable returns activitydiagram::BooleanVariable:
	{iot_lua::BooleanVariableBindStatement_Assignment}
	'bool' delegate=Statement_FunctioncallOrAssignment;

BooleanValue returns activitydiagram::BooleanValue:
	value=EBoolean;

IntegerValue returns activitydiagram::IntegerValue:
	value=Double;

ControlFlow returns activitydiagram::ControlFlow:
	'flow'
	name=ID
		'from' source=[activitydiagram::ActivityNode]
		'to' target=[activitydiagram::ActivityNode]
		('[' guard=[activitydiagram::BooleanVariable] ']')?;

Double returns ecore::EDouble:
	(INT) ('.' INT)?
;